<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot：前后端分离Token校验（Redis鉴权成功自动延长期限）]]></title>
    <url>%2F2018%2F12%2F06%2FSpringBoot%EF%BC%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBToken%E6%A0%A1%E9%AA%8C%EF%BC%88Redis%E9%89%B4%E6%9D%83%E6%88%90%E5%8A%9F%E8%87%AA%E5%8A%A8%E5%BB%B6%E9%95%BF%E6%9C%9F%E9%99%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot：前后端分离Token校验（Redis鉴权成功自动延长期限）pom.xml引入jedis123456&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; token鉴权拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.fufu.interceptor;import com.alibaba.fastjson.JSONObject;import com.fufu.annotation.AuthToken;import com.fufu.constant.SysConstant;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import redis.clients.jedis.Jedis;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;import java.lang.reflect.Method;/** * token鉴权拦截器 */@Componentpublic class AuthorizationInterceptor implements HandlerInterceptor &#123; private final static Logger log = LoggerFactory.getLogger(AuthorizationInterceptor.class); //存放鉴权信息的Header名称，默认是Authorization private String httpHeaderName = &quot;token&quot;; //鉴权失败后返回的错误信息，默认为401 unauthorized private String unauthorizedErrorMessage = &quot;401 unauthorized&quot;; //鉴权失败后返回的HTTP错误码，默认为401 private int unauthorizedErrorCode = HttpServletResponse.SC_UNAUTHORIZED; /** * 存放登录用户模型Key的Request Key */ public static final String REQUEST_CURRENT_KEY = &quot;REQUEST_CURRENT_KEY&quot;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (!(handler instanceof HandlerMethod)) &#123; return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); // 如果打上了AuthToken注解则需要验证token if (method.getAnnotation(AuthToken.class) != null || handlerMethod.getBeanType().getAnnotation(AuthToken.class) != null) &#123; String token = request.getHeader(httpHeaderName); log.info(&quot;token is &#123;&#125;&quot;, token); String username = &quot;&quot;; Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); if (token != null &amp;&amp; token.length() != 0) &#123; username = jedis.get(token); log.info(&quot;username is &#123;&#125;&quot;, username); &#125; if (username != null &amp;&amp; !username.trim().equals(&quot;&quot;)) &#123; //log.info(&quot;token birth time is: &#123;&#125;&quot;,jedis.get(username+token)); Long tokeBirthTime = Long.valueOf(jedis.get(token + username)); log.info(&quot;token Birth time is: &#123;&#125;&quot;, tokeBirthTime); Long diff = System.currentTimeMillis() - tokeBirthTime; log.info(&quot;token is exist : &#123;&#125; ms&quot;, diff); if (diff &gt; SysConstant.TOKEN_RESET_TIME) &#123; jedis.expire(username, SysConstant.TOKEN_EXPIRE_TIME); jedis.expire(token, SysConstant.TOKEN_EXPIRE_TIME); log.info(&quot;Reset expire time success!&quot;); Long newBirthTime = System.currentTimeMillis(); jedis.set(token + username, newBirthTime.toString()); &#125; //用完关闭 jedis.close(); request.setAttribute(REQUEST_CURRENT_KEY, username); return true; &#125; else &#123; JSONObject jsonObject = new JSONObject(); PrintWriter out = null; try &#123; response.setStatus(unauthorizedErrorCode); response.setContentType(MediaType.APPLICATION_JSON_VALUE); jsonObject.put(&quot;ret&quot;, ((HttpServletResponse) response).getStatus()); jsonObject.put(&quot;msg&quot;, HttpStatus.UNAUTHORIZED); out = response.getWriter(); out.println(jsonObject); return false; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != out) &#123; out.flush(); out.close(); &#125; &#125; &#125; &#125; request.setAttribute(REQUEST_CURRENT_KEY, null); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 拦截器添加123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.fufu.interceptor;import com.alibaba.fastjson.JSONObject;import com.fufu.annotation.AuthToken;import com.fufu.constant.SysConstant;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import redis.clients.jedis.Jedis;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;import java.lang.reflect.Method;/** * token鉴权拦截器 */@Componentpublic class AuthorizationInterceptor implements HandlerInterceptor &#123; private final static Logger log = LoggerFactory.getLogger(AuthorizationInterceptor.class); //存放鉴权信息的Header名称，默认是Authorization private String httpHeaderName = &quot;token&quot;; //鉴权失败后返回的错误信息，默认为401 unauthorized private String unauthorizedErrorMessage = &quot;401 unauthorized&quot;; //鉴权失败后返回的HTTP错误码，默认为401 private int unauthorizedErrorCode = HttpServletResponse.SC_UNAUTHORIZED; /** * 存放登录用户模型Key的Request Key */ public static final String REQUEST_CURRENT_KEY = &quot;REQUEST_CURRENT_KEY&quot;; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (!(handler instanceof HandlerMethod)) &#123; return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); // 如果打上了AuthToken注解则需要验证token if (method.getAnnotation(AuthToken.class) != null || handlerMethod.getBeanType().getAnnotation(AuthToken.class) != null) &#123; String token = request.getHeader(httpHeaderName); log.info(&quot;token is &#123;&#125;&quot;, token); String username = &quot;&quot;; Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); if (token != null &amp;&amp; token.length() != 0) &#123; username = jedis.get(token); log.info(&quot;username is &#123;&#125;&quot;, username); &#125; if (username != null &amp;&amp; !username.trim().equals(&quot;&quot;)) &#123; //log.info(&quot;token birth time is: &#123;&#125;&quot;,jedis.get(username+token)); Long tokeBirthTime = Long.valueOf(jedis.get(token + username)); log.info(&quot;token Birth time is: &#123;&#125;&quot;, tokeBirthTime); Long diff = System.currentTimeMillis() - tokeBirthTime; log.info(&quot;token is exist : &#123;&#125; ms&quot;, diff); if (diff &gt; SysConstant.TOKEN_RESET_TIME) &#123; jedis.expire(username, SysConstant.TOKEN_EXPIRE_TIME); jedis.expire(token, SysConstant.TOKEN_EXPIRE_TIME); log.info(&quot;Reset expire time success!&quot;); Long newBirthTime = System.currentTimeMillis(); jedis.set(token + username, newBirthTime.toString()); &#125; //用完关闭 jedis.close(); request.setAttribute(REQUEST_CURRENT_KEY, username); return true; &#125; else &#123; JSONObject jsonObject = new JSONObject(); PrintWriter out = null; try &#123; response.setStatus(unauthorizedErrorCode); response.setContentType(MediaType.APPLICATION_JSON_VALUE); jsonObject.put(&quot;ret&quot;, ((HttpServletResponse) response).getStatus()); jsonObject.put(&quot;msg&quot;, HttpStatus.UNAUTHORIZED); out = response.getWriter(); out.println(jsonObject); return false; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != out) &#123; out.flush(); out.close(); &#125; &#125; &#125; &#125; request.setAttribute(REQUEST_CURRENT_KEY, null); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 系统参数1234567891011121314151617181920212223242526package com.fufu.constant;public final class SysConstant &#123; /** * 设置删除标志为真 */ public static final Integer DEL_FLAG_TRUE = 1; /** * 设置删除标志为假 */ public static final Integer DEL_FLAG_FALSE = 0; /** * redis存储token设置的过期时间 */ public static final Integer TOKEN_EXPIRE_TIME = 60 * 2; /** * 设置可以重置token过期时间的时间界限 */ public static final Integer TOKEN_RESET_TIME = 1000 * 100;&#125; MD5生成token12345678910package com.fufu.tools;import org.springframework.stereotype.Component;@Componentpublic interface TokenGenerator &#123; public String generate(String... strings);&#125; 1234567891011121314151617181920package com.fufu.tools;import org.springframework.stereotype.Component;import org.springframework.util.DigestUtils;@Componentpublic class Md5TokenGenerator implements TokenGenerator &#123; @Override public String generate(String... strings) &#123; long timestamp = System.currentTimeMillis(); String tokenMeta = &quot;&quot;; for (String s : strings) &#123; tokenMeta = tokenMeta + s; &#125; tokenMeta = tokenMeta + timestamp; String token = DigestUtils.md5DigestAsHex(tokenMeta.getBytes()); return token; &#125;&#125; Controller123456789101112131415161718192021@ApiOperation(value=&quot;token鉴权&quot;, notes=&quot;token鉴权&quot;) @GetMapping(value=&quot;loginToken&quot;) @ResponseBody public String login(String username, String password, HttpServletResponse response) &#123; User user = loginService.findByUsername(username); if (user != null &amp;&amp; user.getPassword().equals(password)) &#123; Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); String token = tokenGenerator.generate(username, password); jedis.set(username, token); jedis.expire(username, SysConstant.TOKEN_EXPIRE_TIME); jedis.set(token, username); jedis.expire(token, SysConstant.TOKEN_EXPIRE_TIME); Long currentTime = System.currentTimeMillis(); jedis.set(token + username, currentTime.toString()); //用完关闭 jedis.close(); return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;token&quot;, token).pushData(); &#125; else &#123; return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;token校验失败&quot;).pushData(); &#125; &#125; 效果图 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot：前后端分离Token校验（JWT）]]></title>
    <url>%2F2018%2F12%2F06%2FSpringBoot%EF%BC%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBToken%E6%A0%A1%E9%AA%8C%EF%BC%88JWT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot：前后端分离Token校验（JWT） 前言：我们这个token校验是用SpringBoot集成JWT实现token验证。Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)定义了一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。 pom.xml引入1234567891011&lt;!-- JWT --&gt; &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt; &lt;/dependency&gt; 拦截器配置 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.fufu.config.interceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 拦截配置--调用链 */@Configurationpublic class WebAppConfigurer implements WebMvcConfigurer&#123; @Bean public HandlerInterceptor getLoginInterceptor()&#123; return new SysInterceptor(); &#125; @Override public void addInterceptors(InterceptorRegistry registry)&#123; String[] patterns = new String[] &#123; &quot;/loginToken&quot;,&quot;/*.html&quot;,&quot;/swagger-resources/**&quot;,&quot;/error&quot;,&quot;/static/*&quot;&#125;; registry.addInterceptor(getLoginInterceptor()) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(patterns); &#125; @Override public void addResourceHandlers(ResourceHandlerRegistry registry)&#123; registry.addResourceHandler(&quot;/static/**&quot;) .addResourceLocations(&quot;classpath:/static/&quot;); &#125; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;)//设置允许跨域的路径 .allowedOrigins(&quot;*&quot;)//设置允许跨域请求的域名 .allowCredentials(true)//是否允许证书 不再默认开启 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)//设置允许的方法 .maxAge(3600);//跨域允许时间 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.fufu.config.interceptor;import com.fufu.constant.SystemConstant;import com.fufu.entity.CheckResult;import com.fufu.tools.JsonUtil;import com.fufu.tools.JwtUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.util.StringUtils;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * 拦截器 用户权限校验 */public class SysInterceptor implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(SysInterceptor.class); public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod)&#123; String authHeader = request.getHeader(&quot;token&quot;); if (StringUtils.isEmpty(authHeader)) &#123; logger.info(&quot;Token不存在&quot;); print(response, JsonUtil.getInstance().putData(&quot;ret&quot;, SystemConstant.JWT_ERRCODE_NULL).putData(&quot;msg&quot;, &quot;Token不存在&quot;).pushData()); return false; &#125;else&#123; //验证JWT的签名，返回CheckResult对象 CheckResult checkResult = JwtUtils.validateJWT(authHeader); if (checkResult.isSuccess()) &#123; return true; &#125; else &#123; switch (checkResult.getErrCode()) &#123; // 签名验证不通过 case SystemConstant.JWT_ERRCODE_FAIL: logger.info(&quot;签名验证不通过&quot;); print(response,JsonUtil.getInstance().putData(&quot;ret&quot;, checkResult.getErrCode()).putData(&quot;msg&quot;, &quot;Token验证不通过&quot;).pushData()); break; // 签名过期，返回过期提示码 case SystemConstant.JWT_ERRCODE_EXPIRE: logger.info(&quot;签名过期&quot;); print(response,JsonUtil.getInstance().putData(&quot;ret&quot;, checkResult.getErrCode()).putData(&quot;msg&quot;, &quot;Token过期&quot;).pushData()); break; default: break; &#125; return false; &#125; &#125; &#125;else&#123; return true; &#125; &#125; public void print(HttpServletResponse response, Object message)&#123; try &#123; response.setStatus(HttpStatus.OK.value()); response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache, must-revalidate&quot;); PrintWriter writer = response.getWriter(); writer.write(message.toString()); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; if(response.getStatus()==500)&#123; modelAndView.setViewName(&quot;/error/500&quot;); &#125;else if(response.getStatus()==404)&#123; modelAndView.setViewName(&quot;/error/404&quot;); &#125; &#125; /** * 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， * 这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。 */ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; &#125; entity1234567891011121314151617181920212223242526272829303132333435363738package com.fufu.entity;import io.jsonwebtoken.Claims;/** * 验证信息 */public class CheckResult &#123; private int errCode; private boolean success; private Claims claims; public int getErrCode() &#123; return errCode; &#125; public void setErrCode(int errCode) &#123; this.errCode = errCode; &#125; public boolean isSuccess() &#123; return success; &#125; public void setSuccess(boolean success) &#123; this.success = success; &#125; public Claims getClaims() &#123; return claims; &#125; public void setClaims(Claims claims) &#123; this.claims = claims; &#125;&#125; constant123456789101112131415161718192021package com.fufu.constant;/** * 系统级静态变量 */public class SystemConstant &#123; /** * token */ public static final int RESCODE_REFTOKEN_MSG = 1006; //刷新TOKEN(有返回数据) public static final int RESCODE_REFTOKEN = 1007; //刷新TOKEN public static final int JWT_ERRCODE_NULL = 4000; //Token不存在 public static final int JWT_ERRCODE_EXPIRE = 4001; //Token过期 public static final int JWT_ERRCODE_FAIL = 4002; //验证不通过 /** * JWT */ public static final String JWT_SECERT = &quot;8677df7fc3a34e26a61c034d5ec8245d&quot;; //密匙 public static final long JWT_TTL = 60 * 60 * 1000; //token有效时间&#125; tools1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.fufu.tools;import com.fufu.constant.SystemConstant;import com.fufu.entity.CheckResult;import io.jsonwebtoken.*;import org.bouncycastle.util.encoders.Base64;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Date;/** * jwt加密和解密的工具类 */public class JwtUtils &#123; /** * 签发JWT */ public static String createJWT(String id, String subject, long ttlMillis) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); SecretKey secretKey = generalKey(); JwtBuilder builder = Jwts.builder() .setId(id) .setSubject(subject) // 主题 .setIssuer(&quot;fufu&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey); // 签名算法以及密匙 if (ttlMillis &gt;= 0) &#123; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); builder.setExpiration(expDate); // 过期时间 &#125; return builder.compact(); &#125; /** * 验证JWT */ public static CheckResult validateJWT(String jwtStr) &#123; CheckResult checkResult = new CheckResult(); Claims claims = null; try &#123; claims = parseJWT(jwtStr); checkResult.setSuccess(true); checkResult.setClaims(claims); &#125; catch (ExpiredJwtException e) &#123; checkResult.setErrCode(SystemConstant.JWT_ERRCODE_EXPIRE); checkResult.setSuccess(false); &#125; catch (SignatureException e) &#123; checkResult.setErrCode(SystemConstant.JWT_ERRCODE_FAIL); checkResult.setSuccess(false); &#125; catch (Exception e) &#123; checkResult.setErrCode(SystemConstant.JWT_ERRCODE_FAIL); checkResult.setSuccess(false); &#125; return checkResult; &#125; public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.decode(SystemConstant.JWT_SECERT); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析JWT字符串 */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; Controller12345678910111213141516@RequestMapping(value=&quot;loginToken&quot;) @ResponseBody public String login(String username, String password, HttpServletResponse response) &#123; User user = loginService.findByUsername(username); if(user!=null)&#123; if(user.getPassword().equals(password))&#123; //把token返回给客户端--&gt;客户端保存至cookie--&gt;客户端每次请求附带cookie参数 String JWT = JwtUtils.createJWT(&quot;1&quot;, username, SystemConstant.JWT_TTL); return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;token&quot;, JWT).pushData(); &#125;else&#123; return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;token校验失败&quot;).pushData(); &#125; &#125;else&#123; return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;token校验失败&quot;).pushData(); &#125; &#125; 流程 新增loginToken接口 把token返回给客户端 客户端保存至cookie 客户端每次请求附带cookie参数通过拦截器进行校验 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot：文件上传接收&&http图片获取]]></title>
    <url>%2F2018%2F11%2F29%2FSpringBoot%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%8E%A5%E6%94%B6%26%26http%E5%9B%BE%E7%89%87%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[SpringBoot：文件上传接收&amp;&amp;http图片获取application.yml12345upload: filePath: D:/test/serviceIP: 127.0.0.1servicePort: 8090rootPath: D:\ FileController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184package com.fufu.controller;import com.fufu.service.FileService;import com.fufu.tools.FileTypeUtil;import com.fufu.tools.HttpClient;import com.fufu.tools.UrlUtil;import io.swagger.annotations.ApiOperation;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.util.Base64Utils;import org.springframework.util.FileCopyUtils;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.Part;import java.io.*;import java.net.HttpURLConnection;import java.net.URL;import java.text.SimpleDateFormat;import java.util.*;@RestController@RequestMapping(&quot;/test1&quot;)public class FileController &#123; private static final Logger log = LoggerFactory.getLogger(FileController.class); @Value(&quot;$&#123;upload.filePath&#125;&quot;) private String filePath; @Value(&quot;$&#123;serviceIP&#125;&quot;) private String serviceIP; @Value(&quot;$&#123;servicePort&#125;&quot;) private String servicePort; @Value(&quot;$&#123;rootPath&#125;&quot;) private String rootPath; @Autowired FileService fileService; //接收单个file @PostMapping(&quot;/test/upload1&quot;) public Map&lt;String, String&gt; upload1(@RequestParam(&quot;file&quot;) MultipartFile file) throws IOException &#123; log.info(&quot;[文件类型] - [&#123;&#125;]&quot;, file.getContentType()); log.info(&quot;[文件名称] - [&#123;&#125;]&quot;, file.getOriginalFilename()); log.info(&quot;[文件大小] - [&#123;&#125;]&quot;, file.getSize()); try &#123; file.transferTo(new File(filePath + file.getOriginalFilename())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Map&lt;String, String&gt; result = new HashMap&lt;&gt;(16); result.put(&quot;contentType&quot;, file.getContentType()); result.put(&quot;fileName&quot;, file.getOriginalFilename()); result.put(&quot;fileSize&quot;, file.getSize() + &quot;&quot;); return result; &#125; //接收多个file @PostMapping(&quot;/test/upload2&quot;) public List&lt;Map&lt;String, String&gt;&gt; upload2(@RequestParam(&quot;file&quot;) MultipartFile[] files) throws IOException &#123; if (files == null || files.length == 0) &#123; return null; &#125; List&lt;Map&lt;String, String&gt;&gt; results = new ArrayList&lt;&gt;(); for (MultipartFile file : files) &#123; file.transferTo(new File(filePath + file.getOriginalFilename())); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;contentType&quot;, file.getContentType()); map.put(&quot;fileName&quot;, file.getOriginalFilename()); map.put(&quot;fileSize&quot;, file.getSize() + &quot;&quot;); results.add(map); &#125; return results; &#125; //接收base64图片字符串 @RequestMapping(&quot;/test/upload3&quot;) public void upload2(String base64) throws IOException &#123; final File tempFile = new File(filePath+&quot;upload3.jpg&quot;); //防止有的没传 data:image/jpeg;base64, 的情况 String[] d = base64.split(&quot;base64,&quot;); final byte[] bytes = Base64Utils.decodeFromString(d.length &gt; 1 ? d[1] : d[0]); FileCopyUtils.copy(bytes, tempFile); &#125; //根据http协议下载图片 @RequestMapping(&quot;/test/upload4&quot;) public String downloadFileByURL(String urlStr) throws IOException &#123; URL url = new URL(UrlUtil.toUtf8String(urlStr)); String picPath = filePath+&quot;upload4.jpg&quot;; File file = new File(picPath); // 打开链接 HttpURLConnection conn = (HttpURLConnection) url.openConnection(); // 设置请求方式为&quot;GET&quot; conn.setRequestMethod(&quot;GET&quot;); // 超时响应时间为5秒 conn.setConnectTimeout(5 * 1000); conn.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;Content-Type&quot;, &quot;text/xml;charset=UTF-8&quot;); // 通过输入流获取图片数据 InputStream inStream = conn.getInputStream(); ByteArrayOutputStream outStream = new ByteArrayOutputStream(); // 创建一个Buffer字符串 byte[] buffer = new byte[1024]; // 每次读取的字符串长度，如果为-1，代表全部读取完毕 int len = 0; // 使用一个输入流从buffer里把数据读取出来 while ((len = inStream.read(buffer)) != -1) &#123; // 用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度 outStream.write(buffer, 0, len); &#125; // 关闭输入流 inStream.close(); // 创建输出流 FileOutputStream outStream2 = new FileOutputStream(file); // 写入数据 outStream2.write(outStream.toByteArray()); // 关闭输出流 outStream2.close(); return picPath; &#125; //实现从本地取图片上传到对应服务器上 @GetMapping(value=&quot;/uploadLocalFile&quot;) public void uploadLocalFile()&#123; String relativePath = &quot;test/haha.jpg&quot;; String picUrl = null; try &#123; picUrl = HttpClient.getInstance().uploadFileImpl(&quot;http://&quot;+serviceIP+&quot;:&quot;+servicePort+&quot;/test1/uploadFile&quot;, rootPath + relativePath, &quot;aTestFileName&quot;, null); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;-----picUrl:&quot;+picUrl+&quot;-----&quot;); &#125; /** * 单个文件上传 * @param file * @param folder 文件夹根据上传文件type自动生成 * @param id * @param request * @return * @throws ServletException * @throws IOException */ @ApiOperation(value = &quot;单个文件上传&quot;, notes= &quot;根据type值将所上传图片分文件夹存放，如type=我是一个莫得感情的文件夹，文件路径将为“/我是一个莫得感情的文件夹/20181111/110.jpg”&quot;) @PostMapping(value=&quot;/uploadFile&quot;) public @ResponseBody String uploadFile( MultipartFile file, @RequestParam(defaultValue = &quot;Common&quot;) String type, HttpServletRequest request) throws IOException, ServletException &#123; SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyyMMdd&quot;); String relativePath = null; String finalName = null; if(file != null) &#123; String fileName = file.getOriginalFilename(); //获取文件后缀名 String ext= FileTypeUtil.getFileSuffix(fileName); if(!&quot;jpg&quot;.equalsIgnoreCase(ext)&amp;&amp; !&quot;png&quot;.equalsIgnoreCase(ext)&amp;&amp; !&quot;bmp&quot;.equalsIgnoreCase(ext) &amp;&amp; !&quot;jpeg&quot;.equalsIgnoreCase(ext)) return &quot;上传的图片文件格式不正确&quot;; relativePath = type + &quot;/&quot; + sf.format(new Date()) +&quot;/&quot;; String finalPath = filePath + relativePath; try &#123; finalName = new Random().nextInt(999999) + &quot;.&quot;+ ext; String fullPath = fileService.uploadFile(file.getBytes(), finalPath, finalName); if(fullPath.isEmpty()) &#123; return null; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); return &quot;uploadimg failure: &quot; + e.getMessage(); &#125; &#125;else &#123; Collection&lt;Part&gt; parts = request.getParts(); for (Iterator&lt;Part&gt; iterator = parts.iterator(); iterator.hasNext();) &#123; Part part = iterator.next(); finalName = part.getSubmittedFileName(); relativePath = part.getName() + &quot;/&quot; + sf.format(new Date()) + &quot;/&quot;; String finalPath = filePath + relativePath; fileService.uploadFile(part.getInputStream(), finalPath, finalName); &#125; &#125; return relativePath + finalName; &#125;&#125; HttpClient123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359package com.fufu.tools;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.ContentType;import org.apache.http.entity.mime.MultipartEntityBuilder;import org.apache.http.entity.mime.content.FileBody;import org.apache.http.entity.mime.content.StringBody;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import java.io.*;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * HttpClient */public class HttpClient &#123; /** * 最大线程池 */ public static final int THREAD_POOL_SIZE = 5; public interface HttpClientDownLoadProgress &#123; public void onProgress(int progress); &#125; private static HttpClient httpClientDownload; private ExecutorService downloadExcutorService; private HttpClient() &#123; downloadExcutorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE); &#125; public static HttpClient getInstance() &#123; if (httpClientDownload == null) &#123; httpClientDownload = new HttpClient(); &#125; return httpClientDownload; &#125; /** * 下载文件 * * @param url * @param filePath */ public void download(final String url, final String filePath) &#123; downloadExcutorService.execute(new Runnable() &#123; @Override public void run() &#123; httpDownloadFile(url, filePath, null, null); &#125; &#125;); &#125; /** * 下载文件 * * @param url * @param filePath * @param progress * 进度回调 */ public void download(final String url, final String filePath, final HttpClientDownLoadProgress progress) &#123; downloadExcutorService.execute(new Runnable() &#123; @Override public void run() &#123; httpDownloadFile(url, filePath, progress, null); &#125; &#125;); &#125; /** * 下载文件 * * @param url * @param filePath */ private void httpDownloadFile(String url, String filePath, HttpClientDownLoadProgress progress, Map&lt;String, String&gt; headMap) &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; HttpGet httpGet = new HttpGet(url); setGetHead(httpGet, headMap); CloseableHttpResponse response1 = httpclient.execute(httpGet); try &#123; System.out.println(response1.getStatusLine()); HttpEntity httpEntity = response1.getEntity(); long contentLength = httpEntity.getContentLength(); InputStream is = httpEntity.getContent(); // 根据InputStream 下载文件 ByteArrayOutputStream output = new ByteArrayOutputStream(); byte[] buffer = new byte[4096]; int r = 0; long totalRead = 0; while ((r = is.read(buffer)) &gt; 0) &#123; output.write(buffer, 0, r); totalRead += r; if (progress != null) &#123;// 回调进度 progress.onProgress((int) (totalRead * 100 / contentLength)); &#125; &#125; FileOutputStream fos = new FileOutputStream(filePath); output.writeTo(fos); output.flush(); output.close(); fos.close(); EntityUtils.consume(httpEntity); &#125; finally &#123; response1.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * get请求 * * @param url * @return */ public String httpGet(String url) &#123; return httpGet(url, null); &#125; /** * http get请求 * * @param url * @return */ public String httpGet(String url, Map&lt;String, String&gt; headMap) &#123; String responseContent = null; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; HttpGet httpGet = new HttpGet(url); CloseableHttpResponse response1 = httpclient.execute(httpGet); setGetHead(httpGet, headMap); try &#123; System.out.println(response1.getStatusLine()); HttpEntity entity = response1.getEntity(); responseContent = getRespString(entity); System.out.println(&quot;debug:&quot; + responseContent); EntityUtils.consume(entity); &#125; finally &#123; response1.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return responseContent; &#125; public String httpPost(String url, Map&lt;String, String&gt; paramsMap) &#123; return httpPost(url, paramsMap, null); &#125; /** * http的post请求 * * @param url * @param paramsMap * @return */ public String httpPost(String url, Map&lt;String, String&gt; paramsMap, Map&lt;String, String&gt; headMap) &#123; String responseContent = null; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; HttpPost httpPost = new HttpPost(url); setPostHead(httpPost, headMap); setPostParams(httpPost, paramsMap); CloseableHttpResponse response = httpclient.execute(httpPost); try &#123; System.out.println(response.getStatusLine()); HttpEntity entity = response.getEntity(); responseContent = getRespString(entity); EntityUtils.consume(entity); &#125; finally &#123; response.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; httpclient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;responseContent = &quot; + responseContent); return responseContent; &#125; /** * 设置POST的参数 * * @param httpPost * @param paramsMap * @throws Exception */ private void setPostParams(HttpPost httpPost, Map&lt;String, String&gt; paramsMap) throws Exception &#123; if (paramsMap != null &amp;&amp; paramsMap.size() &gt; 0) &#123; List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); Set&lt;String&gt; keySet = paramsMap.keySet(); for (String key : keySet) &#123; nvps.add(new BasicNameValuePair(key, paramsMap.get(key))); &#125; httpPost.setEntity(new UrlEncodedFormEntity(nvps)); &#125; &#125; /** * 设置http的HEAD * * @param httpPost * @param headMap */ private void setPostHead(HttpPost httpPost, Map&lt;String, String&gt; headMap) &#123; if (headMap != null &amp;&amp; headMap.size() &gt; 0) &#123; Set&lt;String&gt; keySet = headMap.keySet(); for (String key : keySet) &#123; httpPost.addHeader(key, headMap.get(key)); &#125; &#125; &#125; /** * 设置http的HEAD * * @param httpGet * @param headMap */ private void setGetHead(HttpGet httpGet, Map&lt;String, String&gt; headMap) &#123; if (headMap != null &amp;&amp; headMap.size() &gt; 0) &#123; Set&lt;String&gt; keySet = headMap.keySet(); for (String key : keySet) &#123; httpGet.addHeader(key, headMap.get(key)); &#125; &#125; &#125; /** * 上传文件 * * @param serverUrl * 服务器地址 * @param localFilePath * 本地文件路径 * @param serverFieldName * @param params * @return * @throws Exception */ public String uploadFileImpl(String serverUrl, String localFilePath, String serverFieldName, Map&lt;String, String&gt; params) throws Exception &#123; String respStr = null; CloseableHttpClient httpclient = HttpClients.createDefault(); try &#123; HttpPost httppost = new HttpPost(serverUrl); FileBody binFileBody = new FileBody(new File(localFilePath)); MultipartEntityBuilder multipartEntityBuilder = MultipartEntityBuilder .create(); // add the file params multipartEntityBuilder.addPart(serverFieldName, binFileBody); // 设置上传的其他参数 setUploadParams(multipartEntityBuilder, params); HttpEntity reqEntity = multipartEntityBuilder.build(); httppost.setEntity(reqEntity); CloseableHttpResponse response = httpclient.execute(httppost); try &#123; System.out.println(response.getStatusLine()); HttpEntity resEntity = response.getEntity(); respStr = getRespString(resEntity); EntityUtils.consume(resEntity); &#125; finally &#123; response.close(); &#125; &#125; finally &#123; httpclient.close(); &#125; System.out.println(&quot;resp=&quot; + respStr); return respStr; &#125; /** * 设置上传文件时所附带的其他参数 * * @param multipartEntityBuilder * @param params */ private void setUploadParams(MultipartEntityBuilder multipartEntityBuilder, Map&lt;String, String&gt; params) &#123; if (params != null &amp;&amp; params.size() &gt; 0) &#123; Set&lt;String&gt; keys = params.keySet(); for (String key : keys) &#123; multipartEntityBuilder .addPart(key, new StringBody(params.get(key), ContentType.TEXT_PLAIN)); &#125; &#125; &#125; /** * 将返回结果转化为String * * @param entity * @return * @throws Exception */ private String getRespString(HttpEntity entity) throws Exception &#123; if (entity == null) &#123; return null; &#125; InputStream is = entity.getContent(); StringBuffer strBuf = new StringBuffer(); byte[] buffer = new byte[4096]; int r = 0; while ((r = is.read(buffer)) &gt; 0) &#123; strBuf.append(new String(buffer, 0, r, &quot;UTF-8&quot;)); &#125; return strBuf.toString(); &#125;&#125; FileService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.fufu.service;import com.fufu.tools.UrlUtil;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import java.io.*;import java.net.HttpURLConnection;import java.net.URL;import java.text.SimpleDateFormat;import java.util.Date;import java.util.UUID;@Servicepublic class FileService &#123; @Value(&quot;$&#123;upload.filePath&#125;&quot;) private String filePath; public String uploadFile(byte[] file, String finalPath, String finalName)&#123; File targetFile = new File(finalPath); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; FileOutputStream out; try &#123; out = new FileOutputStream(finalPath+finalName); out.write(file); out.flush(); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); return &quot;uploadimg failure: &quot; + e.getMessage(); &#125; System.out.println(finalPath + finalName); return finalPath + finalName; &#125; public void uploadFile(InputStream in, String finalPath, String finalName) throws IOException &#123; File targetFile = new File(finalPath); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; //创建一个文件输出流 FileOutputStream out = new FileOutputStream(finalPath + finalName); //创建一个缓冲区 byte buffer[] = new byte[1024]; //判断输入流中的数据是否已经读完的标识 int len = 0; //循环将输入流读入到缓冲区当中，(len=in.read(buffer))&gt;0就表示in里面还有数据 while((len=in.read(buffer))&gt;0)&#123; //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + &quot;\\&quot; + filename)当中 out.write(buffer, 0, len); &#125; in.close(); //关闭输出流 out.close(); &#125; public String uploadFileByURL(String folder, String urlStr) throws IOException &#123; SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyyMMdd&quot;); String suffix = HttpURLConnection.guessContentTypeFromName(urlStr).split(&quot;/&quot;)[1]; String fileName = UUID.randomUUID()+&quot;.&quot;+suffix; String relativePath = folder +&quot;/&quot; + sf.format(new Date()) +&quot;/&quot;; String absolutePath=filePath.replace(&quot;\\&quot;, &quot;/&quot;) + relativePath; File targetFile = new File(absolutePath); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; URL url = new URL(UrlUtil.toUtf8String(urlStr)); File file = new File(absolutePath+fileName); // 打开链接 HttpURLConnection conn = (HttpURLConnection) url.openConnection(); // 设置请求方式为&quot;GET&quot; conn.setRequestMethod(&quot;GET&quot;); // 超时响应时间为5秒 conn.setConnectTimeout(5 * 1000); conn.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;Content-Type&quot;, &quot;text/xml;charset=UTF-8&quot;); conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;); // 通过输入流获取图片数据 InputStream inStream = conn.getInputStream(); System.out.println(HttpURLConnection.guessContentTypeFromStream(inStream)); ByteArrayOutputStream outStream = new ByteArrayOutputStream(); // 创建一个Buffer字符串 byte[] buffer = new byte[1024]; // 每次读取的字符串长度，如果为-1，代表全部读取完毕 int len = 0; // 使用一个输入流从buffer里把数据读取出来 while ((len = inStream.read(buffer)) != -1) &#123; // 用输出流往buffer里写入数据，中间参数代表从哪个位置开始读，len代表读取的长度 outStream.write(buffer, 0, len); &#125; // 关闭输入流 inStream.close(); // 创建输出流 FileOutputStream outStream2 = new FileOutputStream(file); // 写入数据 outStream2.write(outStream.toByteArray()); // 关闭输出流 outStream2.close(); return relativePath+fileName; &#125;&#125; 简单的文件上传下载示例，具体代码可以下载github下来看看 效果图 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-blog域名解析]]></title>
    <url>%2F2018%2F11%2F28%2FHexo-blog%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Hexo-blog域名解析域名购买我这边是在腾讯云买的 实名认证域名解析 一般wwww CNAME对应hexo-blog项目github登录地址 @ A则对应github提供的两个ip地址 192.30.252.154 和 192.30.252.153 hexo项目 根目录下source下添加CNAME文件（无后缀）内容为你申请的域名 然后部署到github 1234hexo三部曲: hexo clean hexo generate hexo deploy 接下来就可以用买来的域名试试了，ENDing 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>hexo-blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot：整合websocket实现消息推送]]></title>
    <url>%2F2018%2F11%2F27%2FSpringBoot%EF%BC%9A%E6%95%B4%E5%90%88websocket%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[SpringBoot：整合websocket实现消息推送惯例先上pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fufu&lt;/groupId&gt; &lt;artifactId&gt;springbootdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springbootdemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- springboot-aop包,AOP切面注解,Aspectd等相关注解 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;/dependency&gt; &lt;!-- swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- shiro core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro权限控制框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入Spring Boot 内嵌的Tomcat对jsp的解析包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- servlet 依赖的jar包start--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jsp 依赖的jar包start--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl标签 依赖的jar包start--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--redis数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--spring2.0集成redis所需common-pool2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 提供API给Java程式对Microsoft Office格式档案读和写的功能 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传文件需要的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- websocket --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 新增 1234567891011&lt;!-- websocket --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; application.yml这边新增thymeleaf配置，注意该配置适合SpringBoot2.0以上1234567891011121314151617181920212223242526# Spring configurationspring: thymeleaf: #开启模板缓存（默认值：true） cache: false #Check that the template exists before rendering it. check-template: true #检查模板位置是否正确（默认值:true） check-template-location: true #开启MVC Thymeleaf视图解析（默认值：true） enabled: true #模板编码 encoding: UTF-8 #要被排除在解析之外的视图名称列表，用逗号分隔 spring.thymeleaf.excluded-view-names: #要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5) mode: HTML5 #在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/） prefix: classpath:/templates/ #在构建URL时添加到视图名称后的后缀（默认值：.html） suffix: .html #Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始， #只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。 template-resolver-order: #可解析的视图名称列表，用逗号分隔 spring.thymeleaf.view-names: websocket新增配置类123456789101112131415161718package com.fufu.config.websocket;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;/** * 开启WebSocket支持 */@Configurationpublic class WebSocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.fufu.config.websocket;import java.io.IOException;import java.util.concurrent.CopyOnWriteArraySet;import javax.websocket.OnClose;import javax.websocket.OnError;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import org.springframework.stereotype.Component;import org.slf4j.Logger;import org.slf4j.LoggerFactory;@ServerEndpoint(&quot;/websocket/&#123;sid&#125;&quot;)@Componentpublic class WebSocketServer &#123; private final static Logger log = LoggerFactory.getLogger(WebSocketServer.class); //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。 private static int onlineCount = 0; //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。 private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;(); //与某个客户端的连接会话，需要通过它来给客户端发送数据 private Session session; //接收sid private String sid=&quot;&quot;; /** * 连接建立成功调用的方法*/ @OnOpen public void onOpen(Session session,@PathParam(&quot;sid&quot;) String sid) &#123; this.session = session; webSocketSet.add(this); //加入set中 addOnlineCount(); //在线数加1 log.info(&quot;有新窗口开始监听:&quot;+sid+&quot;,当前在线人数为&quot; + getOnlineCount()); this.sid=sid; try &#123; sendMessage(&quot;连接成功&quot;); &#125; catch (IOException e) &#123; log.error(&quot;websocket IO异常&quot;); &#125; &#125; /** * 连接关闭调用的方法 */ @OnClose public void onClose() &#123; webSocketSet.remove(this); //从set中删除 subOnlineCount(); //在线数减1 log.info(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount()); &#125; /** * 收到客户端消息后调用的方法 * * @param message 客户端发送过来的消息*/ @OnMessage public void onMessage(String message, Session session) &#123; log.info(&quot;收到来自窗口&quot;+sid+&quot;的信息:&quot;+message); //群发消息 for (WebSocketServer item : webSocketSet) &#123; try &#123; item.sendMessage(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * * @param session * @param error */ @OnError public void onError(Session session, Throwable error) &#123; log.error(&quot;发生错误&quot;); error.printStackTrace(); &#125; /** * 实现服务器主动推送 */ public void sendMessage(String message) throws IOException &#123; this.session.getBasicRemote().sendText(message); &#125; /** * 群发自定义消息 * */ public static void sendInfo(String message,@PathParam(&quot;sid&quot;) String sid) throws IOException &#123; log.info(&quot;推送消息到窗口&quot;+sid+&quot;，推送内容:&quot;+message); for (WebSocketServer item : webSocketSet) &#123; try &#123; //这里可以设定只推送给这个sid的，为null则全部推送 if(sid==null) &#123; item.sendMessage(message); &#125;else if(item.sid.equals(sid))&#123; item.sendMessage(message); &#125; &#125; catch (IOException e) &#123; continue; &#125; &#125; &#125; public static synchronized int getOnlineCount() &#123; return onlineCount; &#125; public static synchronized void addOnlineCount() &#123; WebSocketServer.onlineCount++; &#125; public static synchronized void subOnlineCount() &#123; WebSocketServer.onlineCount--; &#125;&#125; shiroFilter放开websocket12filterChainDefinitionMap.put(&quot;/websocket/**&quot;, &quot;anon&quot;);filterChainDefinitionMap.put(&quot;/socket/**&quot;, &quot;anon&quot;); Controller1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.fufu.controller;import com.fufu.config.websocket.WebSocketServer;import com.fufu.tools.JsonUtil;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import java.io.IOException;@Controller@RequestMapping(&quot;/websocket&quot;)public class MessagePushController &#123; //页面请求 @GetMapping(&quot;/requestPage&quot;) public String websocket() &#123; return &quot;websocket&quot;; &#125; //推送数据接口 @ResponseBody @RequestMapping(&quot;/socket/push/&#123;cid&#125;&quot;) public String pushToWeb(@PathVariable String cid, String message) &#123; try &#123; WebSocketServer.sendInfo(message,cid); &#125; catch (IOException e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, cid+&quot;#&quot;+e.getMessage()).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;msg&quot;, &quot;推送成功cid为：&quot;+cid).pushData(); &#125; @Scheduled(cron = &quot;0/5 * * * * ?&quot;) public void autoPushToWeb() &#123; try &#123; WebSocketServer.sendInfo(&quot;我是一条5秒一次向web推送的消息~&quot;,&quot;20&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; html测试websocket在resources下的templates新建websocket.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;websocket测试&lt;/title&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;/static/img/favicon.ico&quot;&gt; &lt;meta name=&quot;google-site-verification&quot; content=&quot;tW0wHpS5SAbFhl5Nt9o2G1uXV-G4YIHClYuX5lr1-ZE&quot; /&gt; &lt;script src=&quot;https://libs.cdnjs.net/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/bootstrap/css/bootstrap.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/offcanvas.css&quot;&gt; &lt;link rel=&quot;alternate&quot; hreflang=&quot;en&quot; href=&quot;http://coolaf.com/en&quot; /&gt; &lt;link rel=&quot;alternate&quot; hreflang=&quot;zh&quot; href=&quot;http://coolaf.com/zh&quot; /&gt; &lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot; style=&apos;width:1300px&apos;&gt; &lt;div class=&quot;row row-offcanvas row-offcanvas-right main-contain&quot;&gt; &lt;div class=&quot;col-xs-12 col-sm-8&quot;&gt; &lt;style&gt; .newmessage&#123; width:100%; &#125; .bubble&#123; background-color:lightgreen position: relative; max-width: 240px; word-wrap: break-word; text-align: left; margin-left: 16px; margin-right: 16px; border-radius: 9px; &#125; .bubble:after&#123; position: absolute; border: 4.8px solid transparent; content: &quot; &quot;; top: 20px; &#125; &lt;/style&gt; &lt;h2&gt;&lt;/h2&gt; &lt;div style=&quot;&quot;&gt; &lt;div&gt; &lt;input type=&apos;text&apos; value=&apos;ws://123.207.167.163:9010/ajaxchattest&apos; class=&quot;form-control&quot; style=&apos;width:390px;display:inline&apos;id=&apos;wsaddr&apos;/&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; onclick=&apos;addsocket();&apos;&gt;连接&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; onclick=&apos;closesocket();&apos;&gt;断开&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; onclick=&apos;$(&quot;#wsaddr&quot;).val(&quot;&quot;)&apos;&gt;清空&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; onclick=&apos;$(&quot;#wsaddr&quot;).val(&quot;ws://localhost:9010/ajaxchattest&quot;)&apos;&gt;示例&lt;/button&gt; &lt;/div&gt; &lt;div style=&apos;margin-top:10px;margin-button:10px&apos;&gt; &lt;pre&gt;本工具主要是为了测试服务端websocket功能是否完善可用而开发，主要是利用html5 的websocket去连接服务端的websocket,因此， 无论你是内网还是外网都可使用!服务端只是实现了接受和发送，这里只是测试而已！&lt;/pre&gt; &lt;/div&gt; &lt;div id=&quot;output&quot; style=&quot;border:1px solid #ccc;height:365px;overflow: auto;margin-left:0px&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot; &gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot; style=&apos;&apos;&gt; &lt;input type=&quot;text&quot;id=&apos;message&apos; class=&quot;form-control&quot; style=&apos;width:810px&apos; placeholder=&quot;待发信息&quot; onkeydown=&quot;en(event);&quot;&gt; &lt;span class=&quot;input-group-btn&quot;&gt;&lt;button class=&quot;btn btn-default&quot; type=&quot;button&quot; onclick=&quot;doSend();&quot;&gt;发送&lt;/button&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script language=&quot;javascript&quot;type=&quot;text/javascript&quot;&gt; function formatDate(now) &#123; var year=now.getFullYear(); var month=now.getMonth()+1; var date=now.getDate(); var hour=now.getHours(); var minute=now.getMinutes(); var second=now.getSeconds(); return year+&quot;-&quot;+(month=month&lt;10?(&quot;0&quot;+month):month)+&quot;-&quot;+(date=date&lt;10?(&quot;0&quot;+date):date)+&quot; &quot;+(hour=hour&lt;10?(&quot;0&quot;+hour):hour)+&quot;:&quot;+(minute=minute&lt;10?(&quot;0&quot;+minute):minute)+&quot;:&quot;+(second=second&lt;10?(&quot;0&quot;+second):second); &#125; var output; var websocket; function init() &#123; output = document.getElementById(&quot;output&quot;); testWebSocket(); &#125; function addsocket() &#123; var wsaddr = $(&quot;#wsaddr&quot;).val(); if (wsaddr==&apos;&apos;) &#123; alert(&quot;请填写websocket的地址&quot;); return false; &#125; StartWebSocket(wsaddr); &#125; function closesocket() &#123; websocket.close(); &#125; function StartWebSocket(wsUri) &#123; websocket = new WebSocket(wsUri); websocket.onopen = function(evt) &#123; onOpen(evt) &#125;; websocket.onclose = function(evt) &#123; onClose(evt) &#125;; websocket.onmessage = function(evt) &#123; onMessage(evt) &#125;; websocket.onerror = function(evt) &#123; onError(evt) &#125;; &#125; function onOpen(evt) &#123; writeToScreen(&quot;&lt;span style=&apos;color:red&apos;&gt;连接成功，现在你可以发送信息啦！！！&lt;/span&gt;&quot;); &#125; function onClose(evt) &#123; writeToScreen(&quot;&lt;span style=&apos;color:red&apos;&gt;websocket连接已断开!!!&lt;/span&gt;&quot;); websocket.close(); &#125; function onMessage(evt) &#123; writeToScreen(&apos;&lt;span style=&quot;color:blue&quot;&gt;服务端回应&amp;nbsp;&apos;+formatDate(new Date())+&apos;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;bubble&quot;&gt;&apos;+ evt.data+&apos;&lt;/span&gt;&apos;); &#125; function onError(evt) &#123; writeToScreen(&apos;&lt;span style=&quot;color: red;&quot;&gt;发生错误:&lt;/span&gt; &apos;+ evt.data); &#125; function doSend() &#123; var message=$(&quot;#message&quot;).val(); if (message==&apos;&apos;) &#123; alert(&quot;请先填写发送信息&quot;); $(&quot;#message&quot;).focus(); return false; &#125; if (typeof websocket===&quot;undefined&quot;)&#123; alert(&quot;websocket还没有连接，或者连接失败，请检测&quot;); return false; &#125; if (websocket.readyState==3) &#123; alert(&quot;websocket已经关闭，请重新连接&quot;); return false; &#125; console.log(websocket); $(&quot;#message&quot;).val(&apos;&apos;); writeToScreen(&apos;&lt;span style=&quot;color:green&quot;&gt;你发送的信息&amp;nbsp;&apos;+formatDate(new Date())+&apos;&lt;/span&gt;&lt;br/&gt;&apos;+ message); websocket.send(message); &#125; function writeToScreen(message) &#123; var div = &quot;&lt;div class=&apos;newmessage&apos;&gt;&quot;+message+&quot;&lt;/div&gt;&quot;; var d = $(&quot;#output&quot;); var d=d[0]; var doScroll = d.scrollTop == d.scrollHeight - d.clientHeight; $(&quot;#output&quot;).append(div); if (doScroll) &#123; d.scrollTop = d.scrollHeight - d.clientHeight; &#125; &#125; function en(event)&#123; var evt=evt?evt:(window.event?window.event:null); if (evt.keyCode==13)&#123; doSend() &#125; &#125; &lt;/script&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图 浏览器访问 http://127.0.0.1:8080/websocket/requestPage 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot：Excel文件解析]]></title>
    <url>%2F2018%2F11%2F27%2FSpringBoot%EF%BC%9AExcel%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[SpringBoot：上传Excel文件并转换成javabean保存到数据库pom.xml引入1234567891011121314151617181920212223&lt;!-- 提供API给Java程式对Microsoft Office格式档案读和写的功能 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传文件需要的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 新增工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.fufu.config.excel;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Excel注解，用以生成Excel表格文件 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)public @interface Excel &#123; /** * 列名 * @return */ String name() default &quot;&quot;; /** * 宽度 * @return */ int width() default 20; /** * 忽略该字段 * @return */ boolean skip() default false; /** * 日期格式 默认yyyy-MM-dd HH:mm:ss * @return */ String dateFormat() default &quot;yyyy-MM-dd HH:mm:ss&quot;; /** * 浮点数的精度 * @return */ int precision() default -1; /** * 四舍五入 * @return */ boolean round() default true; &#125; 1234567891011121314151617181920212223242526package com.fufu.config.excel;import java.util.HashMap;import java.util.Map;/** * Excel导入导出数据定义转换&lt;br&gt; * 举例:&lt;br&gt; * 数据导出， &#123;lock,&#123;0:正常，1:锁定&#125;&#125;&lt;br&gt; * 数据导入,&#123;lock,&#123;正常:0，锁定:1&#125;&#125; */public class ExcelDataFormatter &#123; /** * K:&#123;V1:V2&#125; */ private Map&lt;String,Map&lt;String,String&gt;&gt; formatter=new HashMap&lt;String, Map&lt;String,String&gt;&gt;(); public void set(String key, Map&lt;String,String&gt; map)&#123; formatter.put(key, map); &#125; public Map&lt;String,String&gt; get(String key)&#123; return formatter.get(key); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242package com.fufu.config.excel;import org.apache.poi.hssf.usermodel.HSSFDateUtil;import org.apache.poi.ss.usermodel.*;import org.apache.poi.xssf.usermodel.XSSFCell;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.InputStream;import java.lang.reflect.Field;import java.math.BigDecimal;import java.text.NumberFormat;import java.text.SimpleDateFormat;import java.util.*;/** * Excel内容转化成Bean */public class ExcelToBean &#123; private static int etimes = 0; /** * 从文件读取数据，最好是所有的单元格都是文本格式，日期格式要求yyyy-MM-dd HH:mm:ss,布尔类型0：真，1：假 * * @param edf * 数据格式化 * * @param file * Excel文件，支持xlsx后缀，xls的没写，基本一样 * @return * @throws Exception */ @SuppressWarnings(&quot;unchecked&quot;) public static &lt;E&gt; List&lt;E&gt; readFromFile(ExcelDataFormatter edf, InputStream is, Class&lt;?&gt; clazz) throws Exception &#123; Field[] fields = ReflectionUtils.getClassFieldsAndSuperClassFields(clazz); Map&lt;String, String&gt; textToKey = new HashMap&lt;String, String&gt;(); Excel _excel = null; for (Field field : fields) &#123; _excel = field.getAnnotation(Excel.class); if (_excel == null || _excel.skip() == true) &#123; continue; &#125; textToKey.put(_excel.name(), field.getName()); &#125; Workbook wb = new XSSFWorkbook(is); Sheet sheet = wb.getSheetAt(0); Row title = sheet.getRow(0); // 标题数组，后面用到，根据索引去标题名称，通过标题名称去字段名称用到 textToKey String[] titles = new String[title.getPhysicalNumberOfCells()]; for (int i = 0; i &lt; title.getPhysicalNumberOfCells(); i++) &#123; titles[i] = title.getCell(i).getStringCellValue(); &#125; List&lt;E&gt; list = new ArrayList&lt;E&gt;(); E e = null; int rowIndex = 0; int columnCount = titles.length; Cell cell = null; Row row = null; for (Iterator&lt;Row&gt; it = sheet.rowIterator(); it.hasNext();) &#123; row = it.next(); if (rowIndex++ == 0) &#123; continue; &#125; if (row == null) &#123; break; &#125; e = (E)clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) &#123; cell = row.getCell(i); etimes = 0; readCellContent(textToKey.get(titles[i]), fields, cell, e, edf); &#125; list.add(e); &#125; return list; &#125; /** * 从单元格读取数据，根据不同的数据类型，使用不同的方式读取&lt;br&gt; * 有时候POI自作聪明，经常和我们期待的数据格式不一样，会报异常，&lt;br&gt; * 我们这里采取强硬的方式&lt;br&gt; * 使用各种方法，知道尝试到读到数据为止，然后根据Bean的数据类型，进行相应的转换&lt;br&gt; * 如果尝试完了（总共7次），还是不能得到数据，那么抛个异常出来，没办法了 * * @param key * 当前单元格对应的Bean字段 * @param fields * Bean所有的字段数组 * @param cell * 单元格对象 * @param obj * @throws Exception */ public static void readCellContent(String key, Field[] fields, Cell cell, Object obj, ExcelDataFormatter edf) throws Exception &#123; Object o = null; try &#123; switch (cell.getCellType()) &#123; case XSSFCell.CELL_TYPE_BOOLEAN: o = cell.getBooleanCellValue(); break; case XSSFCell.CELL_TYPE_NUMERIC: o = cell.getNumericCellValue(); NumberFormat nf = NumberFormat.getInstance(); String s = nf.format(o); if (s.indexOf(&quot;,&quot;) &gt;= 0) &#123; s = s.replace(&quot;,&quot;, &quot;&quot;); &#125; o = s; if (HSSFDateUtil.isCellDateFormatted(cell)) &#123; o = DateUtil.getJavaDate(cell.getNumericCellValue()); &#125; break; case XSSFCell.CELL_TYPE_STRING: o = cell.getStringCellValue(); break; case XSSFCell.CELL_TYPE_ERROR: o = cell.getErrorCellValue(); break; case XSSFCell.CELL_TYPE_BLANK: o = null; break; case XSSFCell.CELL_TYPE_FORMULA: o = cell.getCellFormula(); break; default: o = null; break; &#125; if (o == null) return; for (Field field : fields) &#123; field.setAccessible(true); if (field.getName().equals(key)) &#123; Boolean bool = true; Map&lt;String, String&gt; map = null; if (edf == null) &#123; bool = false; &#125; else &#123; map = edf.get(field.getName()); if (map == null) &#123; bool = false; &#125; &#125; if (field.getType().equals(Date.class)) &#123; if (o.getClass().equals(Date.class)) &#123; field.set(obj, o); &#125; else &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); field.set(obj, sdf.parse(o.toString())); &#125; &#125; else if (field.getType().equals(String.class)) &#123; if (o.getClass().equals(String.class)) &#123; field.set(obj, o); &#125; else &#123; field.set(obj, o.toString()); &#125; &#125; else if (field.getType().equals(Long.class)) &#123; if (o.getClass().equals(Long.class)) &#123; field.set(obj, o); &#125; else &#123; field.set(obj, Long.parseLong(o.toString())); &#125; &#125; else if (field.getType().equals(Integer.class)) &#123; if (o.getClass().equals(Integer.class)) &#123; field.set(obj, o); &#125; else &#123; // 检查是否需要转换 if (bool) &#123; field.set(obj, map.get(o.toString()) != null ? Integer.parseInt(map.get(o.toString())) : Integer.parseInt(o.toString())); &#125; else &#123; if(!o.getClass().equals(Double.class)) field.set(obj, Integer.parseInt(o.toString())); else field.set(obj, Integer.parseInt(new java.text.DecimalFormat(&quot;0&quot;).format(o))); &#125; &#125; &#125; else if (field.getType().equals(BigDecimal.class)) &#123; if (o.getClass().equals(BigDecimal.class)) &#123; field.set(obj, o); &#125; else &#123; field.set(obj, BigDecimal.valueOf(Double.parseDouble(o.toString()))); &#125; &#125; else if (field.getType().equals(Boolean.class)) &#123; if (o.getClass().equals(Boolean.class)) &#123; field.set(obj, o); &#125; else &#123; // 检查是否需要转换 if (bool) &#123; field.set(obj, map.get(o.toString()) != null ? Boolean.parseBoolean(map.get(o.toString())) : Boolean.parseBoolean(o.toString())); &#125; else &#123; field.set(obj, Boolean.parseBoolean(o.toString())); &#125; &#125; &#125; else if (field.getType().equals(Float.class)) &#123; if (o.getClass().equals(Float.class)) &#123; field.set(obj, o); &#125; else &#123; field.set(obj, Float.parseFloat(o.toString())); &#125; &#125; else if (field.getType().equals(Double.class)) &#123; if (o.getClass().equals(Double.class)) &#123; field.set(obj, o); &#125; else &#123; field.set(obj, Double.parseDouble(o.toString())); &#125; &#125; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); // 如果还是读到的数据格式还是不对，只能放弃了 if (etimes &gt; 7) &#123; throw ex; &#125; etimes++; if (o == null) &#123; readCellContent(key, fields, cell, obj, edf); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344package com.fufu.config.excel;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.Validate;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.lang.reflect.*;/** * 反射工具类. * * 提供调用getter/setter方法, 访问私有变量, 调用私有方法, 获取泛型类型Class, 被AOP过的真实类等工具函数. * * @author lwh */public class ReflectionUtils &#123; private static final String SETTER_PREFIX = &quot;set&quot;; private static final String GETTER_PREFIX = &quot;get&quot;; private static final String CGLIB_CLASS_SEPARATOR = &quot;$$&quot;; private static Logger logger = LoggerFactory.getLogger(ReflectionUtils.class); /** * 调用Getter方法 * @param obj 对象 * @param propertyName 属性名称 * @return obj */ public static Object invokeGetter(Object obj, String propertyName) &#123; String getterMethodName = GETTER_PREFIX + StringUtils.capitalize(propertyName); return invokeMethod(obj, getterMethodName, new Class[] &#123;&#125;, new Object[] &#123;&#125;); &#125; /** * 调用Setter方法, 仅匹配方法名 * @param obj 对象 * @param propertyName 属性名称 * @param value 新值 */ public static void invokeSetter(Object obj, String propertyName, Object value) &#123; String setterMethodName = SETTER_PREFIX + StringUtils.capitalize(propertyName); invokeMethodByName(obj, setterMethodName, new Object[] &#123; value &#125;); &#125; /** * 获取所有的成员变量,包括父类 * * @param clazz * @return 属性集合 * @throws Exception */ public static &lt;T&gt; Field[] getClassFieldsAndSuperClassFields(Class&lt;T&gt; clazz) throws Exception &#123; Field[] fields = clazz.getDeclaredFields(); if (clazz.getSuperclass() == null) &#123; throw new Exception(clazz.getName() + &quot;没有父类&quot;); &#125; Field[] superFields = clazz.getSuperclass().getDeclaredFields(); Field[] allFields = new Field[fields.length + superFields.length]; for (int i = 0; i &lt; fields.length; i++) &#123; allFields[i] = fields[i]; &#125; for (int i = 0; i &lt; superFields.length; i++) &#123; allFields[fields.length + i] = superFields[i]; &#125; return allFields; &#125; /** * 直接读取对象属性值, 无视private/protected修饰符, 不经过getter函数 * @param obj 对象 * @param fieldName 属性名称 * @return */ public static Object getFieldValue(final Object obj, final String fieldName) &#123; Field field = getAccessibleField(obj, fieldName); if (field == null) &#123; throw new IllegalArgumentException(&quot;Could not find field [&quot; + fieldName + &quot;] on target [&quot; + obj + &quot;]&quot;); &#125; Object result = null; try &#123; result = field.get(obj); &#125; catch (IllegalAccessException e) &#123; logger.error(&quot;不可能抛出的异常&#123;&#125;&quot;, e.getMessage()); &#125; return result; &#125; /** * 直接设置对象属性值, 无视private/protected修饰符, 不经过setter函数 * @param obj 对象 * @param fieldName 属性名称 * @param value 新值 */ public static void setFieldValue(final Object obj, final String fieldName, final Object value) &#123; Field field = getAccessibleField(obj, fieldName); if (field == null) &#123; throw new IllegalArgumentException(&quot;Could not find field [&quot; + fieldName + &quot;] on target [&quot; + obj + &quot;]&quot;); &#125; try &#123; field.set(obj, value); &#125; catch (IllegalAccessException e) &#123; logger.error(&quot;不可能抛出的异常:&#123;&#125;&quot;, e.getMessage()); &#125; &#125; /** * 直接调用对象方法, 无视private/protected修饰符. * 用于一次性调用的情况，否则应使用getAccessibleMethod()函数获得Method后反复调用. * 同时匹配方法名+参数类型， * @param obj 对象 * @param methodName 方法名称 * @param parameterTypes 参数类型 * @param args 参数 * @return obj */ public static Object invokeMethod(final Object obj, final String methodName, final Class&lt;?&gt;[] parameterTypes, final Object[] args) &#123; Method method = getAccessibleMethod(obj, methodName, parameterTypes); if (method == null) &#123; throw new IllegalArgumentException(&quot;Could not find method [&quot; + methodName + &quot;] on target [&quot; + obj + &quot;]&quot;); &#125; try &#123; return method.invoke(obj, args); &#125; catch (Exception e) &#123; throw convertReflectionExceptionToUnchecked(e); &#125; &#125; /** * 直接调用对象方法, 无视private/protected修饰符， * 用于一次性调用的情况，否则应使用getAccessibleMethodByName()函数获得Method后反复调用. * 只匹配函数名，如果有多个同名函数调用第一个。 * @param obj 对象 * @param methodName 方法名称 * @param args 参数 * @return */ public static Object invokeMethodByName(final Object obj, final String methodName, final Object[] args) &#123; Method method = getAccessibleMethodByName(obj, methodName); if (method == null) &#123; throw new IllegalArgumentException(&quot;Could not find method [&quot; + methodName + &quot;] on target [&quot; + obj + &quot;]&quot;); &#125; try &#123; return method.invoke(obj, args); &#125; catch (Exception e) &#123; throw convertReflectionExceptionToUnchecked(e); &#125; &#125; /** * 循环向上转型, 获取对象的DeclaredField, 并强制设置为可访问. * * 如向上转型到Object仍无法找到, 返回null. * @param obj 对象 * @param fieldName 属性名称 * @return 属性 */ public static Field getAccessibleField(final Object obj, final String fieldName) &#123; Validate.notNull(obj, &quot;object can&apos;t be null&quot;); Validate.notBlank(fieldName, &quot;fieldName can&apos;t be blank&quot;); for (Class&lt;?&gt; superClass = obj.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()) &#123; try &#123; Field field = superClass.getDeclaredField(fieldName); makeAccessible(field); return field; &#125; catch (NoSuchFieldException e) &#123;// NOSONAR // Field不在当前类定义,继续向上转型 &#125; &#125; return null; &#125; /** * 循环向上转型, 获取对象的DeclaredMethod,并强制设置为可访问. * 如向上转型到Object仍无法找到, 返回null. * 匹配函数名+参数类型。 * * 用于方法需要被多次调用的情况. 先使用本函数先取得Method,然后调用Method.invoke(Object obj, Object... args) * @param obj 对象 * @param methodName 方法名称 * @param parameterTypes 参数类型 * @return 方法 */ public static Method getAccessibleMethod(final Object obj, final String methodName, final Class&lt;?&gt;... parameterTypes) &#123; Validate.notNull(obj, &quot;object can&apos;t be null&quot;); Validate.notBlank(methodName, &quot;methodName can&apos;t be blank&quot;); for (Class&lt;?&gt; searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) &#123; try &#123; Method method = searchType.getDeclaredMethod(methodName, parameterTypes); makeAccessible(method); return method; &#125; catch (NoSuchMethodException e) &#123; // Method不在当前类定义,继续向上转型 &#125; &#125; return null; &#125; /** * 循环向上转型, 获取对象的DeclaredMethod,并强制设置为可访问. * 如向上转型到Object仍无法找到, 返回null. * 只匹配函数名。 * * 用于方法需要被多次调用的情况. 先使用本函数先取得Method,然后调用Method.invoke(Object obj, Object... args) * @param obj 对象 * @param methodName 方法名称 * @return 方法 */ public static Method getAccessibleMethodByName(final Object obj, final String methodName) &#123; Validate.notNull(obj, &quot;object can&apos;t be null&quot;); Validate.notBlank(methodName, &quot;methodName can&apos;t be blank&quot;); for (Class&lt;?&gt; searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) &#123; Method[] methods = searchType.getDeclaredMethods(); for (Method method : methods) &#123; if (method.getName().equals(methodName)) &#123; makeAccessible(method); return method; &#125; &#125; &#125; return null; &#125; /** * 改变private/protected的方法为public，尽量不调用实际改动的语句，避免JDK的SecurityManager抱怨。 * @param method 对象方法 */ public static void makeAccessible(Method method) &#123; if ((!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) &amp;&amp; !method.isAccessible()) &#123; method.setAccessible(true); &#125; &#125; /** * 改变private/protected的成员变量为public，尽量不调用实际改动的语句，避免JDK的SecurityManager抱怨。 * @param field 对象属性 */ public static void makeAccessible(Field field) &#123; if ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()) || Modifier .isFinal(field.getModifiers())) &amp;&amp; !field.isAccessible()) &#123; field.setAccessible(true); &#125; &#125; /** * 通过反射, 获得Class定义中声明的泛型参数的类型, 注意泛型必须定义在父类处 * 如无法找到, 返回Object.class. * eg. * public UserDao extends HibernateDao&lt;User&gt; * * @param clazz The class to introspect * @return the first generic declaration, or Object.class if cannot be determined */ public static &lt;T&gt; Class&lt;T&gt; getClassGenricType(final Class clazz) &#123; return getClassGenricType(clazz, 0); &#125; /** * 通过反射, 获得Class定义中声明的父类的泛型参数的类型. * 如无法找到, 返回Object.class. * * 如public UserDao extends HibernateDao&lt;User,Long&gt; * * @param clazz clazz The class to introspect * @param index the Index of the generic ddeclaration,start from 0. * @return the index generic declaration, or Object.class if cannot be determined */ public static Class getClassGenricType(final Class clazz, final int index) &#123; Type genType = clazz.getGenericSuperclass(); if (!(genType instanceof ParameterizedType)) &#123; logger.warn(clazz.getSimpleName() + &quot;&apos;s superclass not ParameterizedType&quot;); return Object.class; &#125; Type[] params = ((ParameterizedType) genType).getActualTypeArguments(); if ((index &gt;= params.length) || (index &lt; 0)) &#123; logger.warn(&quot;Index: &quot; + index + &quot;, Size of &quot; + clazz.getSimpleName() + &quot;&apos;s Parameterized Type: &quot; + params.length); return Object.class; &#125; if (!(params[index] instanceof Class)) &#123; logger.warn(clazz.getSimpleName() + &quot; not set the actual class on superclass generic parameter&quot;); return Object.class; &#125; return (Class) params[index]; &#125; /** * 获取父类 * @param instance 对象实例 * @return 父类 */ public static Class&lt;?&gt; getUserClass(Object instance) &#123; Class clazz = instance.getClass(); if ((clazz != null) &amp;&amp; clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) &#123; Class&lt;?&gt; superClass = clazz.getSuperclass(); if ((superClass != null) &amp;&amp; !Object.class.equals(superClass)) &#123; return superClass; &#125; &#125; return clazz; &#125; /** * 将反射时的checked exception转换为unchecked exception * @param e exception * @return unchecked exception */ public static RuntimeException convertReflectionExceptionToUnchecked(Exception e) &#123; if ((e instanceof IllegalAccessException) || (e instanceof IllegalArgumentException) || (e instanceof NoSuchMethodException)) &#123; return new IllegalArgumentException(e); &#125; else if (e instanceof InvocationTargetException) &#123; return new RuntimeException(((InvocationTargetException) e).getTargetException()); &#125; else if (e instanceof RuntimeException) &#123; return (RuntimeException) e; &#125; return new RuntimeException(&quot;Unexpected Checked Exception.&quot;, e); &#125;&#125; Controller123456789101112@PostMapping(value = &quot;/excelUpload&quot;) @ResponseBody public String uploadExcel(@RequestParam(&quot;file&quot;) MultipartFile file) throws Exception &#123; if(file==null || file.isEmpty())&#123; return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;上传文件不能为空！&quot;).pushData(); &#125; try&#123; return restfulService.uploadSatelliteExcel(file); &#125;catch(Exception e)&#123; return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, e.getMessage()).pushData(); &#125; &#125; Service1234567891011121314151617181920/** * 上传卫星excel文件 */ public String uploadSatelliteExcel(MultipartFile excelFile)&#123; ExcelDataFormatter edf = new ExcelDataFormatter(); InputStream is = null; try &#123; is = excelFile.getInputStream(); List&lt;Satellite&gt; list = ExcelToBean.readFromFile(edf,is, Satellite.class); satelliteMapper.deleteAll(); for(Satellite satellite : list)&#123; satelliteMapper.insert(satellite); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, e.getMessage()).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;msg&quot;, &quot;上传成功！&quot;).pushData(); &#125; Entity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.fufu.entity;import com.fufu.config.excel.Excel;import java.util.Date;public class Satellite implements java.io.Serializable&#123; private Long id; @Excel(name = &quot;卫星名称&quot;) private String satelliteName; @Excel(name = &quot;编号&quot;) private String satelliteNo; @Excel(name = &quot;国别&quot;) private String country; @Excel(name = &quot;类别&quot;) private Integer satelliteType; @Excel(name = &quot;时间段开始&quot;) private Date startTime; @Excel(name = &quot;时间段结束&quot;) private Date endTime; @Excel(name = &quot;安全时长&quot;) private Integer safeTime; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getSatelliteName() &#123; return satelliteName; &#125; public void setSatelliteName(String satelliteName) &#123; this.satelliteName = satelliteName; &#125; public String getSatelliteNo() &#123; return satelliteNo; &#125; public void setSatelliteNo(String satelliteNo) &#123; this.satelliteNo = satelliteNo; &#125; public String getCountry() &#123; return country; &#125; public void setCountry(String country) &#123; this.country = country; &#125; public Integer getSatelliteType() &#123; return satelliteType; &#125; public void setSatelliteType(Integer satelliteType) &#123; this.satelliteType = satelliteType; &#125; public Date getStartTime() &#123; return startTime; &#125; public void setStartTime(Date startTime) &#123; this.startTime = startTime; &#125; public Date getEndTime() &#123; return endTime; &#125; public void setEndTime(Date endTime) &#123; this.endTime = endTime; &#125; public Integer getSafeTime() &#123; return safeTime; &#125; public void setSafeTime(Integer safeTime) &#123; this.safeTime = safeTime; &#125; &#125; 这里的注解对应Excel的第一行，如图 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot：开启logback默认日志组件]]></title>
    <url>%2F2018%2F11%2F27%2FSpringBoot%EF%BC%9A%E5%BC%80%E5%90%AFlogback%E9%BB%98%E8%AE%A4%E6%97%A5%E5%BF%97%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot：开启logback默认日志组件application.yml配置123456#输出日志文件，默认不输出logging: file: /SpringBootLog.txt#修改日志级别，默认为INFO level: root: DEBUG 在resources下添加logback-spring.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;!-- appender是配置输出终端，ConsoleAppender是控制台,name是自定义名 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;!-- 配置日志格式，这是一个比较通用的格式 --&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 输出终端是滚动文件 --&gt; &lt;appender name=&quot;WARN&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 基于时间滚动，就是每天的日志输出到不同的文件 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 输出日志的目录文件名，window中默认分区为当前程序的硬盘分区，%d&#123;yyyy-MM-dd&#125;是当前日期 --&gt; &lt;fileNamePattern&gt;/log/warn/warn.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;!-- 最大保存99个文件，超出的历史文件会被删除 --&gt; &lt;maxHistory&gt;99&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 按照日志级别进行过滤 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;!-- 只收集WARN级别的日志，其他高级别和低级别的日志都放弃 --&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 除了filter，其他 配置和上面一样， 只是name和文件路径不同--&gt; &lt;appender name=&quot;ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;/log/error/error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;99&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 阈值过滤器 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;!-- 收集ERROR及ERROR以上级别的日志 --&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- root是根日志打印器，只有一个，负责整个系统的日志输出 --&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;!-- 将上面三个输出终端配置到根打印器，将对整个系统 生效。 --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;appender-ref ref=&quot;WARN&quot; /&gt; &lt;appender-ref ref=&quot;ERROR&quot; /&gt; &lt;/root&gt; &lt;!-- logger是root的子打印器，可以有多个，输出name配置的包中的日志。 --&gt; &lt;!-- hello.dao是我的mybatis映射dao的包名，设置为debug可以打印mybatis的sql语句 --&gt; &lt;logger name=&quot;com.fufu.mapper&quot; level=&quot;DEBUG&quot; /&gt;&lt;/configuration&gt; 这个配置分别打印warn和error，可以有效定位问题。 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot：简单整合redis]]></title>
    <url>%2F2018%2F11%2F26%2FSpringBoot%EF%BC%9A%E7%AE%80%E5%8D%95%E6%95%B4%E5%90%88redis%2F</url>
    <content type="text"><![CDATA[SpringBoot：简单整合redisapplication.yml添加配置1234567891011121314151617spring: redis: host: 127.0.0.1 port: 6379 database: 0 timeout: 60s # 数据库连接超时时间，2.0 中该参数的类型为Duration，这里在配置的时候需要指明单位 # 连接池配置，2.0中直接使用jedis或者lettuce配置连接池 jedis: pool: # 最大空闲连接数 max-idle: 500 # 最小空闲连接数 min-idle: 50 # 等待可用连接的最大时间，负数为不限制 max-wait: -1s # 最大活跃连接数，负数为不限制 max-active: -1 这里的配置主要针对SpringBoot2.0以上的版本。 RedisDao12345678910111213141516171819202122232425package com.fufu.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Repository;import java.util.concurrent.TimeUnit;@Repositorypublic class RedisDao &#123; @Autowired private StringRedisTemplate template; public void setKey(String key,String value)&#123; ValueOperations&lt;String, String&gt; ops = template.opsForValue(); ops.set(key,value,1, TimeUnit.MINUTES);//1分钟过期 &#125; public String getValue(String key)&#123; ValueOperations&lt;String, String&gt; ops = this.template.opsForValue(); return ops.get(key); &#125;&#125; 单元测试12345678@Autowired RedisDao redisDao; @Test public void testRedis()&#123; redisDao.setKey(&quot;name&quot;,&quot;fufu&quot;); redisDao.setKey(&quot;age&quot;,&quot;18&quot;); System.out.println(redisDao.getValue(&quot;name&quot;)); System.out.println(redisDao.getValue(&quot;age&quot;)); &#125; 除了StringRedisTemplate，还有其他template大家可以自己尝试下。 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot：整合Shiro鉴权登录与权限管理]]></title>
    <url>%2F2018%2F11%2F26%2FSpringBoot%EF%BC%9A%E6%95%B4%E5%90%88Shiro%E9%89%B4%E6%9D%83%E7%99%BB%E5%BD%95%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[SpringBoot：整合Shiro鉴权登录与权限管理惯例，到目前文章位置的pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fufu&lt;/groupId&gt; &lt;artifactId&gt;springbootdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springbootdemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- springboot-aop包,AOP切面注解,Aspectd等相关注解 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;/dependency&gt; &lt;!-- swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- shiro core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro权限控制框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入Spring Boot 内嵌的Tomcat对jsp的解析包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- servlet 依赖的jar包start--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jsp 依赖的jar包start--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl标签 依赖的jar包start--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 新增部分主要为以下 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- shiro core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro权限控制框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入Spring Boot 内嵌的Tomcat对jsp的解析包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- servlet 依赖的jar包start--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jsp 依赖的jar包start--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl标签 依赖的jar包start--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 主要为shiro和jsp登录界面服务 接下来配置shiro类 配置文件夹新增AuthRealm类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.fufu.config;import com.fufu.entity.Permission;import com.fufu.entity.Role;import com.fufu.entity.User;import com.fufu.service.LoginService;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;import org.springframework.beans.factory.annotation.Autowired;import java.util.Collection;import java.util.HashSet;import java.util.Set;public class AuthRealm extends AuthorizingRealm &#123; @Autowired private LoginService loginService; /** * 为用户授权 * @param principals * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; //获取前端输入的用户信息，封装为User对象 User userweb = (User) principals.getPrimaryPrincipal(); //获取前端输入的用户名 String username = userweb.getUsername(); //根据前端输入的用户名查询数据库中对应的记录 User user = loginService.findByUsername(username); //如果数据库中有该用户名对应的记录，就进行授权操作 if (user != null)&#123; SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //因为addRoles和addStringPermissions方法需要的参数类型是Collection //所以先创建两个collection集合 Collection&lt;String&gt; rolesCollection = new HashSet&lt;String&gt;(); Collection&lt;String&gt; perStringCollection = new HashSet&lt;String&gt;(); //获取user的Role的set集合 Set&lt;Role&gt; roles = user.getRoles(); //遍历集合 for (Role role : roles)&#123; //将每一个role的name装进collection集合 rolesCollection.add(role.getName()); //获取每一个Role的permission的set集合 Set&lt;Permission&gt; permissionSet = role.getPermissions(); //遍历集合 for (Permission permission : permissionSet)&#123; //将每一个permission的name装进collection集合 perStringCollection.add(permission.getName()); &#125; //为用户授权 info.addStringPermissions(perStringCollection); &#125; //为用户授予角色 info.addRoles(rolesCollection); return info; &#125;else&#123; return null; &#125; &#125; /** * 认证登录 * @param token * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //token携带了用户信息 UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token; //获取前端输入的用户名 String userName = usernamePasswordToken.getUsername(); //根据用户名查询数据库中对应的记录 User user = loginService.findByUsername(userName); //当前realm对象的name String realmName = getName(); //盐值 ByteSource credentialsSalt = ByteSource.Util.bytes(user.getUsername()); //封装用户信息，构建AuthenticationInfo对象并返回 AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user, user.getPassword(), credentialsSalt, realmName); return authcInfo; &#125;&#125; 新增ShiroConfiguration类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.fufu.config;import org.apache.shiro.authc.credential.HashedCredentialsMatcher;import org.apache.shiro.spring.LifecycleBeanPostProcessor;import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import java.util.LinkedHashMap;@Configurationpublic class ShiroConfiguration &#123; /** * 密码校验规则HashedCredentialsMatcher * 这个类是为了对密码进行编码的 , * 防止密码在数据库里明码保存 , 当然在登陆认证的时候 , * 这个类也负责对form里输入的密码进行编码 * 处理认证匹配处理器：如果自定义需要实现继承HashedCredentialsMatcher */ @Bean(&quot;hashedCredentialsMatcher&quot;) public HashedCredentialsMatcher hashedCredentialsMatcher() &#123; HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(); //指定加密方式为MD5 credentialsMatcher.setHashAlgorithmName(&quot;MD5&quot;); //加密次数 credentialsMatcher.setHashIterations(1024); credentialsMatcher.setStoredCredentialsHexEncoded(true); return credentialsMatcher; &#125; @Bean(&quot;authRealm&quot;) @DependsOn(&quot;lifecycleBeanPostProcessor&quot;)//可选 public AuthRealm authRealm(@Qualifier(&quot;hashedCredentialsMatcher&quot;) HashedCredentialsMatcher matcher) &#123; AuthRealm authRealm = new AuthRealm(); authRealm.setAuthorizationCachingEnabled(false); authRealm.setCredentialsMatcher(matcher); return authRealm; &#125; /** * 定义安全管理器securityManager,注入自定义的realm * @param authRealm * @return */ @Bean(&quot;securityManager&quot;) public DefaultWebSecurityManager securityManager(@Qualifier(&quot;authRealm&quot;) AuthRealm authRealm) &#123; DefaultWebSecurityManager manager = new DefaultWebSecurityManager(); manager.setRealm(authRealm); return manager; &#125; /** * 定义shiroFilter过滤器并注入securityManager * @param manager * @return */ @Bean(&quot;shiroFilter&quot;) public ShiroFilterFactoryBean shiroFilter(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager manager) &#123; ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //设置securityManager bean.setSecurityManager(manager); //设置登录页面 //可以写路由也可以写jsp页面的访问路径 bean.setLoginUrl(&quot;/login&quot;); //设置登录成功跳转的页面 bean.setSuccessUrl(&quot;/pages/index.jsp&quot;); //设置未授权跳转的页面 bean.setUnauthorizedUrl(&quot;/pages/unauthorized.jsp&quot;); //定义过滤器 LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); filterChainDefinitionMap.put(&quot;/index&quot;, &quot;authc&quot;); filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/loginUser&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/admin&quot;, &quot;roles[admin]&quot;); filterChainDefinitionMap.put(&quot;/edit&quot;, &quot;perms[delete]&quot;); filterChainDefinitionMap.put(&quot;/druid/**&quot;, &quot;anon&quot;); //需要登录访问的资源 , 一般将/**放在最下边 filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;); bean.setFilterChainDefinitionMap(filterChainDefinitionMap); return bean; &#125; /** * Spring的一个bean , 由Advisor决定对哪些类的方法进行AOP代理 . * @return */ @Bean public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() &#123; DefaultAdvisorAutoProxyCreator creator = new DefaultAdvisorAutoProxyCreator(); creator.setProxyTargetClass(true); return creator; &#125; /** * 配置shiro跟spring的关联 * @param securityManager * @return */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor(); advisor.setSecurityManager(securityManager); return advisor; &#125; /** * lifecycleBeanPostProcessor是负责生命周期的 , 初始化和销毁的类 * (可选) */ @Bean(&quot;lifecycleBeanPostProcessor&quot;) public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125;&#125; 接下来MVC三层 entity 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.fufu.entity;import java.util.HashSet;import java.util.Set;public class User &#123; private Integer uid; private String username; private String password; private Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Set&lt;Role&gt; getRoles() &#123; return roles; &#125; public void setRoles(Set&lt;Role&gt; roles) &#123; this.roles = roles; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.fufu.entity;import java.util.HashSet;import java.util.Set;public class Role &#123; private Integer rid; private String name; private Set&lt;Permission&gt; permissions = new HashSet&lt;&gt;(); public Integer getRid() &#123; return rid; &#125; public void setRid(Integer rid) &#123; this.rid = rid; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Set&lt;Permission&gt; getPermissions() &#123; return permissions; &#125; public void setPermissions(Set&lt;Permission&gt; permissions) &#123; this.permissions = permissions; &#125;&#125; 123456789101112131415161718192021package com.fufu.entity;public class Permission &#123; private Integer pid; private String name; public Integer getPid() &#123; return pid; &#125; public void setPid(Integer pid) &#123; this.pid = pid; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.fufu.controller;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.annotation.RequiresRoles;import org.apache.shiro.crypto.hash.SimpleHash;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.ByteSource;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpSession;@Controllerpublic class LoginController&#123; //用户登录 @RequestMapping(&quot;/loginUser&quot;) public String loginUser(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, HttpSession session) &#123; //把前端输入的username和password封装为token UsernamePasswordToken token = new UsernamePasswordToken(username, password); Subject subject = SecurityUtils.getSubject(); try &#123; subject.login(token); session.setAttribute(&quot;user&quot;, subject.getPrincipal()); return &quot;index&quot;; &#125; catch (Exception e) &#123; return &quot;login&quot;; &#125; &#125; //退出登录 @RequestMapping(&quot;/logout&quot;) public String logout() &#123; Subject subject = SecurityUtils.getSubject(); if (subject != null) &#123; subject.logout(); &#125; return &quot;login&quot;; &#125; //访问login时跳到login.jsp @RequestMapping(&quot;/login&quot;) public String login() &#123; return &quot;login&quot;; &#125; //admin角色才能访问 @RequestMapping(&quot;/admin&quot;) @ResponseBody public String admin() &#123; return &quot;admin success&quot;; &#125; //有delete权限才能访问 @RequestMapping(&quot;/edit&quot;) @ResponseBody public String edit() &#123; return &quot;edit success&quot;; &#125; @RequestMapping(&quot;/test&quot;) @ResponseBody @RequiresRoles(&quot;guest&quot;) public String test()&#123; return &quot;test success&quot;; &#125;&#125; service 1234567891011121314151617181920212223242526package com.fufu.service;import com.fufu.config.DS;import com.fufu.entity.BlogVisitor;import com.fufu.entity.User;import com.fufu.entity.UserInfo;import com.fufu.mapper.BlogVisitorMapper;import com.fufu.mapper.UserAuthMapper;import com.fufu.mapper.UserInfoMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Service@Transactionalpublic class LoginService &#123; @Autowired private UserAuthMapper userAuthMapper; //shiro鉴权 @DS(&quot;datasource1&quot;) public User findByUsername(String username) &#123; return userAuthMapper.findByUsername(username); &#125;&#125; mapper 123456789package com.fufu.mapper;import com.fufu.entity.User;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface UserAuthMapper&#123; User findByUsername(String username);&#125; mybatis的mapper.xml UserAuthMapper.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fufu.mapper.UserAuthMapper&quot;&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;com.fufu.entity.User&quot;&gt; &lt;id property=&quot;uid&quot; column=&quot;uid&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;pass_word&quot;/&gt; &lt;collection property=&quot;roles&quot; ofType=&quot;com.fufu.entity.Role&quot;&gt; &lt;id property=&quot;rid&quot; column=&quot;rid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;role_name&quot;/&gt; &lt;collection property=&quot;permissions&quot; ofType=&quot;com.fufu.entity.Permission&quot;&gt; &lt;id property=&quot;pid&quot; column=&quot;pid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;permission_name&quot;/&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;findByUsername&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt; SELECT * FROM login_user u,login_role r,login_permission p WHERE u.rid=r.rid AND p.rid=r.rid AND u.user_name=#&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; jsp视图 新建webapp目录，结构如图 index.jsp 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;fufu登录管理系统&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎登录，$&#123;user.username&#125;&lt;/h1&gt; &lt;a href=&lt;%=request.getContextPath() +&quot;/admin&quot; %&gt;&gt;admin权限访问&lt;/a&gt; &lt;a href=&lt;%=request.getContextPath() +&quot;/test&quot; %&gt;&gt;guest权限访问&lt;/a&gt; &lt;input type = &quot;button&quot; value = &quot;登出&quot; onclick=&quot;javascript:window.location.href=&apos;/logout&apos;;&quot;&gt;&lt;/body&gt;&lt;/html&gt; login.jsp 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎登录！&lt;/h1&gt;&lt;form action=&quot;/loginUser&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; unauthorized.jsp 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Error&lt;/title&gt;&lt;/head&gt;&lt;body&gt;无相应权限!&lt;input type = &quot;button&quot; value = &quot;重新登录&quot; onclick=&quot;javascript:window.location.href=&apos;/logout&apos;;&quot;&gt;&lt;/body&gt;&lt;/html&gt; 与此同时，添加SpringBoot配置文件配置12345spring: mvc: view: prefix: /pages/ suffix: .jsp 数据库层面 三个表 12345678910111213141516171819202122232425262728293031323334/*Navicat MySQL Data TransferSource Server : localhostSource Server Version : 50610Source Host : localhost:3306Source Database : mytest1Target Server Type : MYSQLTarget Server Version : 50610File Encoding : 65001Date: 2018-11-26 15:20:59*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `login_user`-- ----------------------------DROP TABLE IF EXISTS `login_user`;CREATE TABLE `login_user` ( `uid` bigint(20) NOT NULL AUTO_INCREMENT, `user_name` varchar(255) DEFAULT NULL, `pass_word` varchar(255) DEFAULT NULL, `rid` bigint(20) DEFAULT NULL, PRIMARY KEY (`uid`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;-- ------------------------------ Records of login_user-- ----------------------------INSERT INTO `login_user` VALUES (&apos;1&apos;, &apos;admin&apos;, &apos;df655ad8d3229f3269fad2a8bab59b6c&apos;, &apos;1&apos;);INSERT INTO `login_user` VALUES (&apos;2&apos;, &apos;guest&apos;, &apos;7c6104076beb13d44ff28e371c8da8b4&apos;, &apos;2&apos;); 1234567891011121314151617181920212223242526272829303132/*Navicat MySQL Data TransferSource Server : localhostSource Server Version : 50610Source Host : localhost:3306Source Database : mytest1Target Server Type : MYSQLTarget Server Version : 50610File Encoding : 65001Date: 2018-11-26 15:21:06*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `login_role`-- ----------------------------DROP TABLE IF EXISTS `login_role`;CREATE TABLE `login_role` ( `rid` bigint(20) NOT NULL AUTO_INCREMENT, `role_name` varchar(255) DEFAULT NULL, PRIMARY KEY (`rid`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;-- ------------------------------ Records of login_role-- ----------------------------INSERT INTO `login_role` VALUES (&apos;1&apos;, &apos;admin&apos;);INSERT INTO `login_role` VALUES (&apos;2&apos;, &apos;guest&apos;); 123456789101112131415161718192021222324252627282930313233343536/*Navicat MySQL Data TransferSource Server : localhostSource Server Version : 50610Source Host : localhost:3306Source Database : mytest1Target Server Type : MYSQLTarget Server Version : 50610File Encoding : 65001Date: 2018-11-26 15:21:11*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `login_permission`-- ----------------------------DROP TABLE IF EXISTS `login_permission`;CREATE TABLE `login_permission` ( `pid` bigint(20) NOT NULL AUTO_INCREMENT, `permission_name` varchar(255) DEFAULT NULL, `rid` bigint(20) DEFAULT NULL, PRIMARY KEY (`pid`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;-- ------------------------------ Records of login_permission-- ----------------------------INSERT INTO `login_permission` VALUES (&apos;1&apos;, &apos;query&apos;, &apos;1&apos;);INSERT INTO `login_permission` VALUES (&apos;2&apos;, &apos;delete&apos;, &apos;1&apos;);INSERT INTO `login_permission` VALUES (&apos;3&apos;, &apos;update&apos;, &apos;1&apos;);INSERT INTO `login_permission` VALUES (&apos;4&apos;, &apos;create&apos;, &apos;1&apos;);INSERT INTO `login_permission` VALUES (&apos;5&apos;, &apos;query&apos;, &apos;2&apos;); 这里的login_user表的密码需要自己用单元测试进行加密 1234567891011121314151617181920212223package com.fufu.httprequest;import com.fufu.SpringBootDemoApplication;import org.apache.shiro.crypto.hash.SimpleHash;import org.apache.shiro.util.ByteSource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(classes = SpringBootDemoApplication.class)public class SpringBootDemoApplicationTests &#123; @Test public void passwordMD5() &#123; String hashAlgorithName = &quot;MD5&quot;; String password = &quot;123&quot;; int hashIterations = 1024;//加密次数 ByteSource credentialsSalt = ByteSource.Util.bytes(&quot;guest&quot;); Object obj = new SimpleHash(hashAlgorithName, password, credentialsSalt, hashIterations); System.out.println(obj); &#125;&#125; 说明我们可以用@RequiresRoles(“guest”)来指定访问角色，可以通过ShiroConfiguration里的shiroFilter过滤器来进行过滤，代码里面已经有角色和权限配置的示例了 效果图 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot：整合mybatis-generate && 多数据源多事务 && Druid sql监控]]></title>
    <url>%2F2018%2F11%2F23%2FSpring%20Boot%EF%BC%9A%E6%95%B4%E5%90%88mybatis-generate%20%26%26%20%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%A4%9A%E4%BA%8B%E5%8A%A1%20%26%26%20Druid%20sql%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[Spring Boot：整合mybatis-generate &amp;&amp; 多数据源多事务 &amp;&amp; Druid sql监控开头贴上整个项目目前为止的pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fufu&lt;/groupId&gt; &lt;artifactId&gt;springbootdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springbootdemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot-aop包,AOP切面注解,Aspectd等相关注解 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 整合mybatis-generate 这里 pom.xml 里只要在build-plugin下加上generator就可以了 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在resources下新建文件generatorConfig.xml，文件内容 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location=&quot;D:\software\apache-tomcat-7.0.52\lib\mysql-connector-java-5.1.23.jar&quot;/&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1/mytest2&quot; userId=&quot;root&quot; password=&quot;orcl&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage=&quot;com.fufu.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;mappering&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.fufu.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName=&quot;user_info&quot; domainObjectName=&quot;UserInfo&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 这里多数据源的也可以参考我的目录结果，多建个generator目录，需要的时候复制到外面的generatorConfig.xml文件就可以了 idea启动配置 这里要注意不要重复生成，重复生成会在**Mapper.xml添加重复的sql，这个很难发现 接下来是多数据源、多事务和Druid整合 因为要配置多数据源，所以要把DataSourceAutoConfiguration.class去掉 12在启动类上加上@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;) 创建DataSourceConfig类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.fufu.config;import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import javax.sql.DataSource;import java.util.HashMap;import java.util.Map;/** * 多数据源配置类 */@Configurationpublic class DataSourceConfig &#123; //数据源1 @Bean(name = &quot;datasource1&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.primary&quot;) // application.properteis中对应属性的前缀 public DataSource dataSource1() &#123; return DruidDataSourceBuilder.create().build(); &#125; //数据源2 @Bean(name = &quot;datasource2&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;) // application.properteis中对应属性的前缀 public DataSource dataSource2() &#123; return DruidDataSourceBuilder.create().build(); &#125; //druid @Bean public ServletRegistrationBean druidStatViewServlet() &#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); registrationBean.addInitParameter(&quot;allow&quot;, &quot;127.0.0.1&quot;); // IP白名单 (没有配置或者为空，则允许所有访问) registrationBean.addInitParameter(&quot;deny&quot;, &quot;&quot;); // IP黑名单 (存在共同时，deny优先于allow) registrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;admin&quot;); registrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;admin&quot;); registrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;); return registrationBean; &#125; @Bean public FilterRegistrationBean druidWebStatViewFilter() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(new WebStatFilter()); registrationBean.addInitParameter(&quot;urlPatterns&quot;, &quot;/*&quot;); registrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*&quot;); return registrationBean; &#125; /** * 动态数据源: 通过AOP在不同数据源之间动态切换 * @return */ @Primary @Bean(name = &quot;dynamicDataSource&quot;) public DataSource dynamicDataSource() &#123; DynamicDataSource dynamicDataSource = new DynamicDataSource(); // 默认数据源 dynamicDataSource.setDefaultTargetDataSource(dataSource1()); // 配置多数据源 Map&lt;Object, Object&gt; dsMap = new HashMap(); dsMap.put(&quot;datasource1&quot;, dataSource1()); dsMap.put(&quot;datasource2&quot;, dataSource2()); dynamicDataSource.setTargetDataSources(dsMap); return dynamicDataSource; &#125; /** * 配置@Transactional注解事物 * @return */ @Bean public PlatformTransactionManager transactionManager() &#123; return new DataSourceTransactionManager(dynamicDataSource()); &#125;&#125; 创建DataSourceContextHolder类 1234567891011121314151617181920212223242526package com.fufu.config;public class DataSourceContextHolder &#123; /** * 默认数据源 */ public static final String DEFAULT_DS = &quot;datasource1&quot;; private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;(); // 设置数据源名 public static void setDB(String dbType) &#123; System.out.println(&quot;切换到&#123;&quot;+dbType+&quot;&#125;数据源&quot;); contextHolder.set(dbType); &#125; // 获取数据源名 public static String getDB() &#123; return (contextHolder.get()); &#125; // 清除数据源名 public static void clearDB() &#123; contextHolder.remove(); &#125;&#125; 创建DS注解动态切换数据源 123456789101112131415package com.fufu.config;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 自定义注解 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface DS &#123; String value() default &quot;datasource1&quot;;&#125; 创建DynamicDataSource类 1234567891011package com.fufu.config;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; System.out.println(&quot;数据源为&quot;+DataSourceContextHolder.getDB()); return DataSourceContextHolder.getDB(); &#125;&#125; 创建DynamicDataSourceAspect类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.fufu.config;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import java.lang.reflect.Method;/** * 自定义注解 + AOP的方式实现数据源动态切换。 */@Aspect@Component@Order(0)public class DynamicDataSourceAspect &#123; @Before(&quot;@annotation(DS)&quot;) public void beforeSwitchDS(JoinPoint point)&#123; //获得当前访问的class Class&lt;?&gt; className = point.getTarget().getClass(); //获得访问的方法名 String methodName = point.getSignature().getName(); //得到方法的参数的类型 Class[] argClass = ((MethodSignature)point.getSignature()).getParameterTypes(); String dataSource = DataSourceContextHolder.DEFAULT_DS; try &#123; // 得到访问的方法对象 Method method = className.getMethod(methodName, argClass); // 判断是否存在@DS注解 if (method.isAnnotationPresent(DS.class)) &#123; DS annotation = method.getAnnotation(DS.class); // 取出注解中的数据源名 dataSource = annotation.value(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 切换数据源 DataSourceContextHolder.setDB(dataSource); &#125; @After(&quot;@annotation(DS)&quot;) public void afterSwitchDS(JoinPoint point)&#123; DataSourceContextHolder.clearDB(); &#125;&#125; 这里说下我踩过的坑吧，DataSourceConfig.java中的数据源配置需要设置一个@Primary作为默认数据源 还有DynamicDataSourceAspect.java数据源切换的时候，需要加个@Order(0)，不然事务开启时，数据源也会切换失败！ 这是我的Controller层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.fufu.controller;import com.fufu.entity.BlogVisitor;import com.fufu.entity.UserInfo;import com.fufu.service.RestfulService;import com.fufu.tools.JsonUtil;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.web.bind.annotation.*;import java.util.List;@RestController@EnableTransactionManagement@RequestMapping(value = &quot;/blogvisitor&quot;)public class RestfulController &#123; @Autowired RestfulService restfulService; @ApiOperation(value=&quot;添加访客&quot;, notes=&quot;添加访客&quot;) @PostMapping(value = &quot;/add&quot;, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;) public String addBlogVisitor(@RequestBody BlogVisitor blogVisitor) &#123; try &#123; restfulService.addBlogVisitor(blogVisitor); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;保存访问者失败!&quot;).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,blogVisitor).putData(&quot;msg&quot;, &quot;保存访问者成功!&quot;).pushData(); &#125; @ApiOperation(value=&quot;删除访客&quot;, notes=&quot;删除访客&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;访客id&quot;, required = true, dataType = &quot;Long&quot;) @GetMapping(value = &quot;/delete&quot;, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;) public String deleteBlogVisitor(Long id) &#123; try &#123; restfulService.deleteBlogVisitor(id); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;删除访问者失败!&quot;).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;msg&quot;, &quot;删除访问者成功!&quot;).pushData(); &#125; @ApiOperation(value=&quot;更新访客&quot;, notes=&quot;更新访客&quot;) @PostMapping(value = &quot;/update&quot;, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;) public String updateBlogVisitor(@RequestBody BlogVisitor blogVisitor) &#123; try &#123; restfulService.updateBlogVisitor(blogVisitor); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;更新访问者失败!&quot;).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;msg&quot;, &quot;更新访问者成功!&quot;).pushData(); &#125; @ApiOperation(value=&quot;查询访客列表&quot;, notes=&quot;查询访客列表&quot;) @GetMapping(value = &quot;/qry&quot;) public String qryBlogVisitorList(@RequestParam(defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123; PageHelper.startPage(pageNum,pageSize); //pageNum表示页数, pageSize表示每页的大小 PageHelper.orderBy(&quot;visit_time DESC&quot;); //进行分页结果的排序，visit_time为字段名，排序规则DESC/ASC List&lt;BlogVisitor&gt; resultList = null; PageInfo pageInfo = null; try &#123; resultList = restfulService.qryBlogVisitorList(); pageInfo = new PageInfo&lt;BlogVisitor&gt;(resultList); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询访问者失败!&quot;).pushData(); &#125; if(resultList == null) return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询不到数据!&quot;).pushData(); return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,pageInfo).putData(&quot;msg&quot;, &quot;查询访问者成功!&quot;).pushData(); &#125; @ApiOperation(value=&quot;查询用戶列表&quot;, notes=&quot;查询用戶列表&quot;) @GetMapping(value = &quot;/qryUser&quot;) public String qryUserList(@RequestParam(defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123; PageHelper.startPage(pageNum,pageSize); //pageNum表示页数, pageSize表示每页的大小 List&lt;UserInfo&gt; resultList = null; PageInfo pageInfo = null; try &#123; resultList = restfulService.qryUserList(); pageInfo = new PageInfo&lt;UserInfo&gt;(resultList); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询用戶失败!&quot;).pushData(); &#125; if(resultList == null) return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询不到数据!&quot;).pushData(); return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,pageInfo).putData(&quot;msg&quot;, &quot;查询用戶成功!&quot;).pushData(); &#125; @ApiOperation(value=&quot;添加用户&quot;, notes=&quot;添加用户&quot;) @PostMapping(value = &quot;/addUser&quot;, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;) public String addUser(@RequestBody UserInfo userInfo) &#123; restfulService.addUserInfo(userInfo);// return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;保存访问者失败!&quot;).pushData(); return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,userInfo).putData(&quot;msg&quot;, &quot;保存访问者成功!&quot;).pushData(); &#125;&#125; Service层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.fufu.service;import com.fufu.config.DS;import com.fufu.entity.BlogVisitor;import com.fufu.entity.UserInfo;import com.fufu.mapper.BlogVisitorMapper;import com.fufu.mapper.UserInfoMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Service@Transactionalpublic class RestfulService &#123; @Autowired private BlogVisitorMapper blogVisitorMapper; @Autowired private UserInfoMapper userInfoMapper; @DS(&quot;datasource1&quot;) public void addBlogVisitor(BlogVisitor blogVisitor) &#123; blogVisitor.setVisitorName(&quot;i am tester&quot;); blogVisitorMapper.insert(blogVisitor); throw new ArithmeticException(&quot;heiheihei&quot;);//事务测试 &#125; @DS(&quot;datasource1&quot;) public void deleteBlogVisitor(Long id) &#123; blogVisitorMapper.deleteByPrimaryKey(id); &#125; @DS(&quot;datasource1&quot;) public void updateBlogVisitor(BlogVisitor blogVisitor) &#123; blogVisitorMapper.updateByPrimaryKey(blogVisitor); &#125; @DS(&quot;datasource1&quot;) public List&lt;BlogVisitor&gt; qryBlogVisitorList() &#123; return blogVisitorMapper.selectAll(); &#125; @DS(&quot;datasource2&quot;) public List&lt;UserInfo&gt; qryUserList()throws Exception &#123; return userInfoMapper.selectAll(); &#125; @DS(&quot;datasource2&quot;) public void addUserInfo(UserInfo userInfo)&#123; userInfo.setUserName(&quot;i am master&quot;); userInfoMapper.insert(userInfo);// throw new RuntimeException(&quot;heiheihei&quot;);//事务测试 &#125;&#125; SpringBoot配置文件 application.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115server: port: 8080# datasource:# #使用druid连接池# type: com.alibaba.druid.pool.DruidDataSource# db1:# jdbc-url: jdbc:mysql://127.0.0.1:3306/mytest1?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false# username: root# password: orcl# driver-class-name: com.mysql.jdbc.Driver# db2:# jdbc-url: jdbc:mysql://127.0.0.1:3306/mytest2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false# username: root# password: orcl# driver-class-name: com.mysql.jdbc.Driver## 该配置节点为独立的节点，有很多同学容易将这个配置放在spring的节点下，导致配置无法被识别mybatis: mapper-locations: classpath:/mappering/*.xml #注意：一定要对应mapper映射xml文件的所在路径 type-aliases-package: com.fufu.mapper# config-locations: classpath:mybatis/mybatis-config.xml#pagehelperpagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql returnPageInfo: check# Spring configurationspring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 thymeleaf: cache: false mvc: view: prefix: /pages/ suffix: .jsp #Multi DataSource Config datasource: primary: url: jdbc:mysql://localhost:3306/mytest1 username: root password: orcl driver-class-name: com.mysql.jdbc.Driver ###################以下为druid增加的配置########################### type: com.alibaba.druid.pool.DruidDataSource # 下面为连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 5 minIdle: 5 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙，此处是filter修改的地方 filters: commons-log.connection-logger-name: stat,wall,log4j # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true slave: url: jdbc:mysql://localhost:3306/mytest2 username: root password: orcl driver-class-name: com.mysql.jdbc.Driver ###################以下为druid增加的配置########################### type: com.alibaba.druid.pool.DruidDataSource # 下面为连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 5 minIdle: 5 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙，此处是filter修改的地方 filters: commons-log.connection-logger-name: stat,wall,log4j # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true# jpa:# show-sql: true# hibernate:# ddl-auto: update# properties:# hibernate:# dialect: org.hibernate.dialect.PostgreSQLDialect druid浏览器访问: http://localhost:8080/druid/ 这里可能有同学有疑问，druid怎么就整合好了，druid整合其实很简单，pom.xml添加依赖，修改SpringBoot配置文件支持druid，最后则是DataSourceConfig里面配置两个druid初始化参数bean，我的druid的Springboot配置也就是application.yml，是适合SpringBoot 2.0的，如果配置不对应会在 http://localhost:8080/druid/ 里的显示找不到数据源。 druid效果图 感谢 这篇文章aop切换数据源主要参考自 https://blog.csdn.net/xiaosheng_papa/article/details/80218006 ，其中一个不足是切面那没加@Order，会导致数据源切换失败，并且没法实现多事务，并在这基础上增加了druid多数据源监控。 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于SpringBoot找不到dataSource or dataSourceClassName or jdbcUrl]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%85%B3%E4%BA%8ESpringBoot%E6%89%BE%E4%B8%8D%E5%88%B0dataSource%20or%20dataSourceClassName%20or%20jdbcUrl%2F</url>
    <content type="text"><![CDATA[关于SpringBoot找不到dataSource or dataSourceClassName or jdbcUrl12345配置多个数据源启动报错，error querying database. Cause: java.lang.IllegalArgumentException: dataSource or dataSourceClassName or jdbcUrl is required，主要原因是在1.0 配置数据源的过程中主要是写成：spring.datasource.url 和spring.datasource.driverClassName。而在2.0升级之后需要变更成：spring.datasource.jdbc-url和spring.datasource.driver-class-name即可解决！ 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot： SpringBoot：添加在mybatis基础上添加分页功能]]></title>
    <url>%2F2018%2F11%2F18%2FSpringBoot%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%9C%A8mybatis%E5%9F%BA%E7%A1%80%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[SpringBoot：添加在mybatis基础上添加分页功能pom.xml123456&lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; 在启动类SpringBootDemoApplication里面添加1234567891011@Bean public PageHelper pageHelper() &#123; System.out.println(&quot;MyBatisConfiguration.pageHelper()&quot;); PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty(&quot;offsetAsPageNum&quot;, &quot;true&quot;); p.setProperty(&quot;rowBoundsWithCount&quot;, &quot;true&quot;); p.setProperty(&quot;reasonable&quot;, &quot;true&quot;); pageHelper.setProperties(p); return pageHelper; &#125; 然后再我们的查询接口里加上123PageHelper.startPage(pageNum,pageSize); //pageNum表示页数, pageSize表示每页的大小PageHelper.orderBy(&quot;visit_time DESC &quot;); //进行分页结果的排序，visit_time为字段名，排序规则DESC/ASCpageInfo = new PageInfo&lt;BlogVisitor&gt;(resultList);//pageInfo是用来包装查询结果，使得有分页信息返回给调用者 接口示例123456789101112131415161718@ApiOperation(value=&quot;查询访客列表&quot;, notes=&quot;查询访客列表&quot;) @GetMapping(value = &quot;/qry&quot;) public String qryBlogVisitorList(@RequestParam(defaultValue = &quot;1&quot;) Integer pageNum, @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123; PageHelper.startPage(pageNum,pageSize); //pageNum表示页数, pageSize表示每页的大小 PageHelper.orderBy(&quot;visit_time DESC &quot;); //进行分页结果的排序，visit_time为字段名，排序规则DESC/ASC List&lt;BlogVisitor&gt; resultList = null; PageInfo pageInfo = null; try &#123; resultList = restfulService.qryBlogVisitorList(); pageInfo = new PageInfo&lt;BlogVisitor&gt;(resultList); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询访问者失败!&quot;).pushData(); &#125; if(resultList == null) return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询不到数据!&quot;).pushData(); return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,pageInfo).putData(&quot;msg&quot;, &quot;查询访问者成功!&quot;).pushData(); &#125; 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot：Restful 接口集成swagger2 api文档]]></title>
    <url>%2F2018%2F11%2F17%2FSpringBoot%EF%BC%9ARestful%20%E6%8E%A5%E5%8F%A3%E9%9B%86%E6%88%90swagger2%20api%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[SpringBoot：Restful 接口集成swagger2 api文档springboot项目结构 pox.xml增加依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; config目录下新增SwaggerUI类12345678910111213141516171819202122232425262728293031323334package com.fufu.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerUI &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.fufu&quot;))//指定扫描的包 .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; //api文档信息 return new ApiInfoBuilder() .title(&quot;swagger-ui构建api文档&quot;) .description(&quot;简单优雅的restful&quot;) .termsOfServiceUrl(&quot;待定&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.fufu.restfuldemo.controller;import com.fufu.restfuldemo.entity.BlogVisitor;import com.fufu.restfuldemo.service.RestfulService;import com.fufu.restfuldemo.tools.JsonUtil;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestController@EnableTransactionManagement //事务管理public class RestfulController &#123; @Autowired RestfulService restfulService; @ApiOperation(value=&quot;添加访客&quot;, notes=&quot;添加访客&quot;) @RequestMapping(value = &quot;/addBlogVisitor&quot;, method = RequestMethod.POST) public String addBlogVisitor(BlogVisitor blogVisitor) &#123; try &#123; restfulService.addBlogVisitor(blogVisitor); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;保存访问者失败!&quot;).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,blogVisitor).putData(&quot;msg&quot;, &quot;保存访问者成功!&quot;).pushData(); &#125; @ApiOperation(value=&quot;删除访客&quot;, notes=&quot;删除访客&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;访客id&quot;, required = true, dataType = &quot;Long&quot;) @RequestMapping(value = &quot;/deleteBlogVisitor&quot;,method = RequestMethod.DELETE) public String deleteBlogVisitor(Long id) &#123; try &#123; restfulService.deleteBlogVisitor(id); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;删除访问者失败!&quot;).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;msg&quot;, &quot;删除访问者成功!&quot;).pushData(); &#125; @ApiOperation(value=&quot;更新访客&quot;, notes=&quot;更新访客&quot;) @RequestMapping(value = &quot;/updateBlogVisitor&quot;,method = RequestMethod.POST) public String updateBlogVisitor(BlogVisitor blogVisitor) &#123; try &#123; restfulService.updateBlogVisitor(blogVisitor); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;更新访问者失败!&quot;).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;msg&quot;, &quot;更新访问者成功!&quot;).pushData(); &#125; @ApiOperation(value=&quot;查询访客列表&quot;, notes=&quot;查询访客列表&quot;) @RequestMapping(value = &quot;/qryBlogVisitorList&quot;,method = RequestMethod.GET) public String qryBlogVisitorList() &#123; List&lt;BlogVisitor&gt; resultList = null; try &#123; resultList = restfulService.qryBlogVisitorList(); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询访问者失败!&quot;).pushData(); &#125; if(resultList == null) return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询不到数据!&quot;).pushData(); return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,resultList).putData(&quot;msg&quot;, &quot;查询访问者成功!&quot;).pushData(); &#125;&#125; 访问swagger2从springboot第一篇文章 SpringBoot：Restful 接口示例 得知我们server port为8090，所以访问http://localhost:8090/swagger-ui.html 效果图 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http请求工具类]]></title>
    <url>%2F2018%2F11%2F16%2Fhttp%E8%AF%B7%E6%B1%82%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[http请求工具类 这个一个能自己配置请求url、请求方法、请求的媒体类型信息、请求的参数的http工具类 HttpUtil类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.fufu.httprequest.tools;import java.io.BufferedReader;import java.io.DataOutputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.util.List;import java.util.Map;public class HttpUtil &#123; public static String httpRequest(String generalUrl,String requestMethod, String contentType, String params) throws Exception &#123; String encoding = &quot;UTF-8&quot;; if (generalUrl.contains(&quot;nlp&quot;)) &#123; encoding = &quot;GBK&quot;; &#125; URL url = new URL(generalUrl); // 打开和URL之间的连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(requestMethod); // 设置通用的请求属性 connection.setRequestProperty(&quot;Content-Type&quot;, contentType); connection.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;); connection.setUseCaches(false); connection.setDoOutput(true); connection.setDoInput(true); // 得到请求的输出流对象 DataOutputStream out = new DataOutputStream(connection.getOutputStream()); out.write(params.getBytes(encoding)); out.flush(); out.close(); // 建立实际的连接 connection.connect(); // 获取所有响应头字段 Map&lt;String, List&lt;String&gt;&gt; headers = connection.getHeaderFields(); // 遍历所有的响应头字段// for (String key : headers.keySet()) &#123;// System.err.println(key + &quot;---&gt;&quot; + headers.get(key));// &#125; // 定义 BufferedReader输入流来读取URL的响应 BufferedReader in = null; in = new BufferedReader( new InputStreamReader(connection.getInputStream(), encoding)); String result = &quot;&quot;; String getLine; while ((getLine = in.readLine()) != null) &#123; result += getLine; &#125; in.close();// System.err.println(&quot;result:&quot; + result); return result; &#125;&#125; test方法12345678910111213141516171819202122232425package com.fufu.httprequest;import com.fufu.httprequest.tools.HttpUtil;import net.sf.json.JSONObject;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class HttprequestApplicationTests &#123; @Test public void contextLoads() &#123; try &#123; String result = HttpUtil.httpRequest(&quot;http://localhost:8080/robotservice/visitorRecord/qryVisitedUnit&quot;,&quot;POST&quot;,&quot;application/x-www-form-urlencoded&quot;,&quot;telNum=1555&quot;); JSONObject jobj = JSONObject.fromObject(result); System.out.println(jobj.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>开发日常记录</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsonUtil操作类]]></title>
    <url>%2F2018%2F11%2F16%2FJsonUtil%E6%93%8D%E4%BD%9C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[JsonUtil操作类json工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.fufu.restfuldemo.tools;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;/** * json操作类 */public class JsonUtil &#123; private JSONObject jo; private JsonUtil() &#123; &#125; /** * 获取单例 * * @return */ public static JsonUtil getInstance() &#123; return new JsonUtil(); &#125; /** * 将数据装载到json里面支持链式 * * @param key * @param value * @return */ public JsonUtil putData(String key, Object value) &#123; if (jo == null) &#123; jo = new JSONObject(); &#125; jo.put(key, value == null ? &quot;&quot; : value); return this; &#125; /** * 将JSONObject转成字符并置为空 * * @return */ public String pushData() &#123; if (jo != null) &#123; JSONObject _jo = jo; jo = null; return JSON.toJSONStringWithDateFormat(_jo, &quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; else &#123; return null; &#125; &#125; /** * 获取jsonObject * s * @return */ public JSONObject getJo() &#123; return jo; &#125; &#125; 用法1JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,一个object).putData(&quot;msg&quot;, &quot;保存访问者成功!&quot;).pushData();//返回json string 该工具的有点就是支持链式化拼接json，另外结合了fastjson的toJSONStringWithDateFormat解决了mybatis查询出来的日期为时间戳格式的问题。 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>开发日常记录</category>
      </categories>
      <tags>
        <tag>JsonUtil</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson java后台json数据格式转化]]></title>
    <url>%2F2018%2F11%2F16%2Ffastjson%20java%E5%90%8E%E5%8F%B0json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[fastjson java后台json数据格式转化maven123456&lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; 数据格式转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 序列化 */ public void toJsonString() &#123; User user = new User(&quot;testFastJson001&quot;, &quot;maks&quot;, 105); String text = JSON.toJSONString(user); System.out.println(&quot;toJsonString()方法：text=&quot; + text); // 输出结果：text=&#123;&quot;age&quot;:105,&quot;id&quot;:&quot;testFastJson001&quot;,&quot;name&quot;:&quot;maks&quot;&#125; &#125; /** * 反序列化为json对象 */ public void parseJsonObject() &#123; String text = &quot;&#123;\&quot;age\&quot;:105,\&quot;id\&quot;:\&quot;testFastJson001\&quot;,\&quot;name\&quot;:\&quot;maks\&quot;&#125;&quot;; JSONObject json = JSON.parseObject(text); System.out.println(&quot;parseJsonObject()方法：json==&quot; + json); // 输出结果：json==&#123;&quot;age&quot;:105,&quot;id&quot;:&quot;testFastJson001&quot;,&quot;name&quot;:&quot;maks&quot;&#125; &#125; /** * 反序列化为javaBean对象 */ public void parseBeanObject() &#123; String text = &quot;&#123;\&quot;age\&quot;:105,\&quot;id\&quot;:\&quot;testFastJson001\&quot;,\&quot;name\&quot;:\&quot;maks\&quot;&#125;&quot;; User user = (User) JSON.parseObject(text, User.class); System.out.println(&quot;parseBeanObject()方法：user==&quot; + user.getId() + &quot;,&quot; + user.getName() + &quot;,&quot; + user.getAge()); // 输出结果：user==testFastJson001,maks,105 &#125; /** * 将javaBean转化为json对象 */ public void bean2Json() &#123; User user = new User(&quot;testFastJson001&quot;, &quot;maks&quot;, 105); JSONObject jsonObj = (JSONObject) JSON.toJSON(user); System.out.println(&quot;bean2Json()方法：jsonObj==&quot; + jsonObj); // 输出结果：jsonObj==&#123;&quot;age&quot;:105,&quot;id&quot;:&quot;testFastJson001&quot;,&quot;name&quot;:&quot;maks&quot;&#125; &#125; /** * 全序列化 直接把java bean序列化为json文本之后，能够按照原来的类型反序列化回来。支持全序列化，需要打开SerializerFeature.WriteClassName特性 */ public void parseJSONAndBeanEachother() &#123; User user = new User(&quot;testFastJson001&quot;, &quot;maks&quot;, 105); SerializerFeature[] featureArr = &#123; SerializerFeature.WriteClassName &#125;; String text = JSON.toJSONString(user, featureArr); System.out.println(&quot;parseJSONAndBeanEachother()方法：text==&quot; + text); // 输出结果：text==&#123;&quot;@type&quot;:&quot;fastJson.test.User&quot;,&quot;age&quot;:105,&quot;id&quot;:&quot;testFastJson001&quot;,&quot;name&quot;:&quot;maks&quot;&#125; User userObj = (User) JSON.parse(text); System.out.println(&quot;parseJSONAndBeanEachother()方法：userObj==&quot; + userObj.getId() + &quot;,&quot; + userObj.getName() + &quot;,&quot; + userObj.getAge()); // 输出结果：userObj==testFastJson001,maks,105 &#125; 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>开发日常记录</category>
      </categories>
      <tags>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot： Restful 接口示例]]></title>
    <url>%2F2018%2F11%2F16%2FSpringBoot%EF%BC%9ARestful%20%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[SpringBoot： Restful 接口示例新建springboot工程 工程目录 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fufu&lt;/groupId&gt; &lt;artifactId&gt;springbootdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springbootdemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接依赖 --&gt; &lt;!-- 添加 MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 MySQL --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.properties123456spring.datasource.url=jdbc:mysql://127.0.0.1:3306/root?useUnicode=true&amp;characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driverserver.port=8090 mysql sql执行12345678910111213141516171819202122232425262728293031323334353637/*Navicat MySQL Data TransferSource Server : localhostSource Server Version : 50610Source Host : localhost:3306Source Database : robotTarget Server Type : MYSQLTarget Server Version : 50610File Encoding : 65001Date: 2018-11-16 16:05:04*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `blog_visitor`-- ----------------------------DROP TABLE IF EXISTS `blog_visitor`;CREATE TABLE `blog_visitor` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `visitor_name` varchar(255) DEFAULT NULL COMMENT &apos;来访姓名&apos;, `visitor_gender` varchar(255) DEFAULT NULL COMMENT &apos;来访者性别&apos;, `visitor_reason` varchar(255) DEFAULT NULL COMMENT &apos;来访事由&apos;, `visit_time` datetime DEFAULT NULL COMMENT &apos;访问时间&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;-- ------------------------------ Records of blog_visitor-- ----------------------------INSERT INTO `blog_visitor` VALUES (&apos;1&apos;, &apos;徐凤年&apos;, &apos;男&apos;, &apos;到此一游&apos;, &apos;2018-11-15 15:11:22&apos;);INSERT INTO `blog_visitor` VALUES (&apos;2&apos;, &apos;姜妮&apos;, &apos;女&apos;, &apos;我跟徐凤年来的&apos;, &apos;2018-11-15 15:11:22&apos;);INSERT INTO `blog_visitor` VALUES (&apos;3&apos;, &apos;南北&apos;, &apos;男&apos;, &apos;我跟东西来的&apos;, &apos;2018-11-15 15:11:22&apos;);INSERT INTO `blog_visitor` VALUES (&apos;4&apos;, &apos;东西&apos;, &apos;女&apos;, &apos;本侠女要来的&apos;, &apos;2018-11-15 15:11:22&apos;); entity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.fufu.entity;import java.util.Date;public class BlogVisitor &#123; private int id ; private String visitorName ; private String visitorGender; private String visitorReason; private Date visitTime; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getVisitorName() &#123; return visitorName; &#125; public void setVisitorName(String visitorName) &#123; this.visitorName = visitorName; &#125; public String getVisitorGender() &#123; return visitorGender; &#125; public void setVisitorGender(String visitorGender) &#123; this.visitorGender = visitorGender; &#125; public String getVisitorReason() &#123; return visitorReason; &#125; public void setVisitorReason(String visitorReason) &#123; this.visitorReason = visitorReason; &#125; public Date getVisitTime() &#123; return visitTime; &#125; public void setVisitTime(Date visitTime) &#123; this.visitTime = visitTime; &#125;&#125; controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.fufu.controller;import com.fufu.entity.BlogVisitor;import com.fufu.service.RestfulService;import com.fufu.tools.JsonUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestController@EnableTransactionManagement //事务管理@RequestMapping(&quot;/restfulapi&quot;)public class RestfulController &#123; @Autowired RestfulService restfulService; @RequestMapping(value = &quot;/addBlogVisitor&quot;, method = RequestMethod.POST) public String addBlogVisitor(BlogVisitor blogVisitor) &#123; try &#123; restfulService.addBlogVisitor(blogVisitor); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;保存访问者失败!&quot;).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,blogVisitor).putData(&quot;msg&quot;, &quot;保存访问者成功!&quot;).pushData(); &#125; @RequestMapping(value = &quot;/deleteBlogVisitor&quot;,method = RequestMethod.DELETE) public String deleteBlogVisitor(Long id) &#123; try &#123; restfulService.deleteBlogVisitor(id); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;删除访问者失败!&quot;).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;msg&quot;, &quot;删除访问者成功!&quot;).pushData(); &#125; @RequestMapping(value = &quot;/updateBlogVisitor&quot;,method = RequestMethod.POST) public String updateBlogVisitor(BlogVisitor blogVisitor) &#123; try &#123; restfulService.updateBlogVisitor(blogVisitor); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;更新访问者失败!&quot;).pushData(); &#125; return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;msg&quot;, &quot;更新访问者成功!&quot;).pushData(); &#125; @RequestMapping(value = &quot;/qryBlogVisitorList&quot;,method = RequestMethod.GET) public String qryBlogVisitorList() &#123; List&lt;BlogVisitor&gt; resultList = null; try &#123; resultList = restfulService.qryBlogVisitorList(); &#125; catch (Exception e) &#123; e.printStackTrace(); return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询访问者失败!&quot;).pushData(); &#125; if(resultList == null) return JsonUtil.getInstance().putData(&quot;ret&quot;, -1).putData(&quot;msg&quot;, &quot;查询不到数据!&quot;).pushData(); return JsonUtil.getInstance().putData(&quot;ret&quot;, 1).putData(&quot;data&quot;,resultList).putData(&quot;msg&quot;, &quot;查询访问者成功!&quot;).pushData(); &#125;&#125; 这里的JsonUtil请参考本blog工具类文章 JsonUtil操作类 mybatis查询出来的日期为时间戳格式，我这边是在JsonUtil里用fastjson统一进行日期格式化 service12345678910111213141516171819202122232425262728293031323334353637383940package com.fufu.service;import com.fufu.dao.BlogVisitorMapper;import com.fufu.entity.BlogVisitor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Service@Transactionalpublic class RestfulService &#123; @Autowired private BlogVisitorMapper blogVisitorMapper; public void addBlogVisitor(BlogVisitor blogVisitor)throws Exception &#123; blogVisitorMapper.addBlogVisitor(blogVisitor); throw new RuntimeException(&quot;heiheihei&quot;);//事务测试 &#125; public void deleteBlogVisitor(Long id) &#123; blogVisitorMapper.deleteBlogVisitor(id); &#125; public void updateBlogVisitor(BlogVisitor blogVisitor) &#123; blogVisitorMapper.updateBlogVisitor(blogVisitor); &#125; public List&lt;BlogVisitor&gt; qryBlogVisitorList() &#123; return blogVisitorMapper.qryBlogVisitorList(); &#125; public BlogVisitorMapper getBlogVisitorMapper() &#123; return blogVisitorMapper; &#125; public void setBlogVisitorMapper(BlogVisitorMapper blogVisitorMapper) &#123; this.blogVisitorMapper = blogVisitorMapper; &#125;&#125; dao123456789101112131415161718192021package com.fufu.dao;import com.fufu.entity.BlogVisitor;import org.apache.ibatis.annotations.*;import java.util.List;@Mapperpublic interface BlogVisitorMapper &#123; @Insert(&quot;insert into blog_visitor(visitor_name, visitor_gender, visitor_reason, visit_time) values(#&#123;visitorName&#125;, #&#123;visitorGender&#125;, #&#123;visitorReason&#125;, #&#123;visitTime&#125;)&quot;) @Options(useGeneratedKeys = true, keyColumn = &quot;id&quot;, keyProperty = &quot;id&quot;) void addBlogVisitor(BlogVisitor blogVisitor); @Delete(&quot;delete from blog_visitor where id = #&#123;id&#125;&quot;) void deleteBlogVisitor(@Param(&quot;id&quot;) Long id); @Update(&quot;update blog_visitor set visitor_name = #&#123;visitorName&#125;, visitor_gender = #&#123;visitorGender&#125;, visitor_reason = #&#123;visitorReason&#125;, visit_time = #&#123;visitTime&#125; where id = #&#123;id&#125;&quot;) void updateBlogVisitor(BlogVisitor blogVisitor); @Select(&quot;select id, visitor_name as visitorName, visitor_gender as visitorGender, visitor_reason as visitorReason, visit_time as visitTime from blog_visitor&quot;) List&lt;BlogVisitor&gt; qryBlogVisitorList();&#125; 源码：https://github.com/qq1028951741/springbootdemo or 右上角github进去，springbootdemo项目，如果对您有帮助，麻烦点下star，谢谢 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>SpringBoot整合系列</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 中 byte[\]、File、InputStream 互相转换]]></title>
    <url>%2F2018%2F11%2F16%2Fjava%20%E4%B8%AD%20byte%5B%5D%E3%80%81File%E3%80%81InputStream%20%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[java 中 byte[]、File、InputStream 互相转换 将File、FileInputStream 转换为byte数组： 1234567File file = new File(&quot;test.txt&quot;);InputStream input = new FileInputStream(file);byte[] byt = new byte[input.available()];input.read(byt); 将byte数组转换为InputStream： 123byte[] byt = new byte[1024];InputStream input = new ByteArrayInputStream(byt); 将byte数组转换为File : 1234567File file = new File(&apos;&apos;);OutputStream output = new FileOutputStream(file);BufferedOutputStream bufferedOutput = new BufferedOutputStream(output);bufferedOutput.write(byt); 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>开发日常记录</category>
      </categories>
      <tags>
        <tag>byte</tag>
        <tag>File</tag>
        <tag>InputStream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片base64编码转MultipartFile]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%9B%BE%E7%89%87base64%E7%BC%96%E7%A0%81%E8%BD%ACMultipartFile%2F</url>
    <content type="text"><![CDATA[图片base64编码转MultipartFiletips:图片base64编码传到后端还需要经过url编码，否则会出现+号丢失新建BASE64DecodedMultipartFile类实现MultipartFile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.*.tools;import org.springframework.web.multipart.MultipartFile;import java.io.*;public class BASE64DecodedMultipartFile implements MultipartFile &#123; private final byte[] imgContent; private final String header; public BASE64DecodedMultipartFile(byte[] imgContent, String header) &#123; this.imgContent = imgContent; this.header = header.split(&quot;;&quot;)[0]; &#125; @Override public String getName() &#123; // TODO - implementation depends on your requirements return System.currentTimeMillis() + Math.random() + &quot;.&quot; + header.split(&quot;/&quot;)[1]; &#125; @Override public String getOriginalFilename() &#123; // TODO - implementation depends on your requirements return System.currentTimeMillis() + (int)Math.random() * 10000 + &quot;.&quot; + header.split(&quot;/&quot;)[1]; &#125; @Override public String getContentType() &#123; // TODO - implementation depends on your requirements return header.split(&quot;:&quot;)[1]; &#125; @Override public boolean isEmpty() &#123; return imgContent == null || imgContent.length == 0; &#125; @Override public long getSize() &#123; return imgContent.length; &#125; @Override public byte[] getBytes() throws IOException &#123; return imgContent; &#125; @Override public InputStream getInputStream() throws IOException &#123; return new ByteArrayInputStream(imgContent); &#125; @Override public void transferTo(File dest) throws IOException, IllegalStateException &#123; new FileOutputStream(dest).write(imgContent); &#125;&#125; 新建tools.java，在里面里添加123456789101112131415161718 //base64转Multipartpublic static MultipartFile base64ToMultipart(String base64) &#123; try &#123; String[] baseStrs = base64.split(&quot;,&quot;); BASE64Decoder decoder = new BASE64Decoder(); byte[] b = new byte[0]; b = decoder.decodeBuffer(baseStrs[1]); for(int i = 0; i &lt; b.length; ++i) &#123; if (b[i] &lt; 0) &#123; b[i] += 256; &#125; &#125; return new BASE64DecodedMultipartFile(b, baseStrs[0]); &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125;&#125; 代码调用1MultipartFile file = tools.base64ToMultipart(&quot;你的图片base64编码，这之前要先urldecode&quot;); 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>开发日常记录</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为hexo-blog增加评论功能]]></title>
    <url>%2F2018%2F11%2F10%2Fhexo4%2F</url>
    <content type="text"><![CDATA[为hexo-blog增加评论功能 如果一个博客活着不是为了相互交流，那么我们开始吧，评论功能主要用LeanCloud+Valine集成的。 先注册LeanCloud网址：https://leancloud.cn/ LeanCloud操作 创建应用 进入设置，安全中心选项设置安全域名 存储选项中创建Class，相当于一个放评论的数据库表 进入设置，应用key选项，记下appid和appkey Valine这边hexo相关主题已经有相应配置 具体参考 在hexo中的使用https://valine.js.org/hexo.html 所以只需修改我们hexo中主题的配置文件 123456789101112valine: enable: true appid: appkey: notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 友善发言的人运气不会太差~ --小黄即 avatar: mm # gravatar style 头像设置看上面那个网址 #avatar: wavatar guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true 部署git bash 键入 hexo d -g ,访问 http://你的用户名.github.io/ 效果图 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>hexo-blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将hexo-blog部署到github]]></title>
    <url>%2F2018%2F11%2F10%2Fhexo3%2F</url>
    <content type="text"><![CDATA[将hexo-blog部署到github注册github创建仓库Create a new repository 记住自己取的repository name 将hexo和github关联起来 hexo文件夹，鼠标右键，点击Git Base Here，键入 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 新建一个文件存放生成的ssh密匙文件，鼠标右键，点击Git Base Here 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 生成两个文件id_rsa和id_rsa.pub 在github上添加公匙 用户头像→Settings→SSH and GPG keys→New SSH key→将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮。 修改hexo站点配置文件 123456789# Deployment 注释## Docs: https://hexo.io/docs/deployment.htmldeploy: # 类型 type: git # 仓库 repo: git@github.com:你的用户名/你的用户名.github.io.git # 分支 branch: master 部署hexo到github123456# 清空静态页面hexo clean# 生成静态页面hexo generate# 部署 hexo deploy 访问 https://你的用户名.github.io/ ，也可去仓库那看看自己的链接 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>hexo-blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让hexo-blog更像一个blog]]></title>
    <url>%2F2018%2F11%2F10%2Fhexo2%2F</url>
    <content type="text"><![CDATA[让hexo-blog更像一个blog hexo自带的blog样本可能不太满足我们对一个blog的追求，所以我们可以对站点配置和主题配置文件进行相应修改 我们先给hexo-选择一个主题可以从https://github.com/hexojs/hexo/wiki/Themes 选择一个喜欢的主题，到对应github复制地址，git clone到hexo文件夹 git clone git@github.com:litten/hexo-theme-yilia.git themes/yilia 配置文件位置12345678910111213.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题| ├── 主题名 #主题名| ├── _config.yml 我是主题配置文件├── _config.yml #全局配置文件 我是站点配置文件└── package.json 以上站点配置文件和主题配置文件位置 配置文件配置 站点配置文件 改博客title，描述，汉化，时区，主题 12345678910111213# Site blog信息设置title: 燃情岁月subtitle: 嘿嘿嘿description: fufublogkeywords:author: fufualanguage: zh-CNtimezone: Asia/Shanghai #广州貌似没有 用上海了# Extensions 主题设置## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 主题配置文件 这里主要改了主题风格和侧边栏显示位置、菜单改成了中文 1234567891011121314151617181920# Schemes 这里是四种主题风格选择#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini#侧边栏位置设置sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). #position: left position: right#菜单设置 menu: 主页: / || home #archives: /archives 目录: /categories || th 标签: /tags || tags #commonweal: /404.html 关于我: /about || user# Enable/Disable menu icons / item badges.# ||后面是图标指向 为菜单加点料 hexo文件夹中右击git bash here 依次键入hexo new page tags、hexo new page categories、hexo new page about 12345678910111213. ├── source #博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里 | ├── _posts #文章 | ├── about #关于我 | ├── categories #目录 | ├── index.md #markdown文件 | ├── images #图片 | └── tags #标签 ├── themes #主题 | ├── 主题名 #主题名 | ├── _config.yml 我是主题配置文件 ├── _config.yml #全局配置文件 我是站点配置文件 └── package.json 以categories为例，修改index.md，type一定要有 123456---title: 目录date: 2018-11-10 09:57:57type: &quot;categories&quot;comments: false--- 这是about的index.md 123456---title: 关于我date: 2018-11-10 09:59:15comments: false---我就是我，不一样的烟火~ 关于新增一篇文章这边有两种方法 git bash，键入hexo new 我是一个栗子 或直接在_posts新建.md文件 修改.md文件，栗子 12345678910---title: 我是一个栗子date: 2018-11-10 10:18:13categories:- 栗子tags:- hexo---&lt;Excerpt in index | 首页摘要&gt; &lt;!-- more --&gt;&lt;The rest of contents | 余下全文&gt; 下面你想怎么markdown就怎么markdown more是为了在首页可以不显示整篇文章 来个blog头像 主题配置文件配置 123avatar: #这个是主题source下的image文件夹 url: /images/header.jpg 效果图 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>hexo-blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美化hexo-blog]]></title>
    <url>%2F2018%2F11%2F10%2Fhexo5%2F</url>
    <content type="text"><![CDATA[屏蔽blog网页底部强力驱动主题配置文件配置如下 123456789101112copyright:powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: falsetheme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false 更改底部footer图标 找到喜欢的图标 https:/www.thinkcmf.com/font/font_awesome/icons.html 主题配置文件修改 123footer: icon: name: star-o 每个图标都有对应的class，如下 1&lt;i class=&quot;fa fa-star-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 我们取class fa fa-后面的名字填写在主题配置文件相应位置 让图标跳动起来 查看 123456. ├── source ├── themes #主题 | ├── next #主题名 | ├── layout | ├── _partials 下的footer.swig 文件的 &lt;span class=&quot;with-love&quot; id=&quot;animate&quot;&gt; 在一下位置修改custom.styl 1234567. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── css | ├── _custom 新增 12345678910111213// 自定义页脚跳动样式@keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;#animate &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 168);&#125; #animate 取自 第二小点的id 增加底部访客统计功能123456. ├── source ├── themes #主题 | ├── next #主题名 | ├── layout | ├── _partials 在_partials目录下找到footer.swig文件，在文件最上面加上 &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 在powered-by前加上 1234567891011&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-smile-o&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 欢迎光临，您是第 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 位访客&lt;/span&gt;&lt;/div&gt;&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-hand-o-right&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次&lt;/span&gt;&lt;/div&gt; 效果图 添加文章版权声明 在目录 123456. ├── source ├── themes #主题 | ├── next #主题名 | ├── layout | ├── _macro 下新增文件my-copyright.swig 123456789101112131415161718192021222324252627282930313233&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css&quot;&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:mm:ss&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:mm:ss&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); clipboard.on(&apos;success&apos;, $(function()&#123; $(&quot;.fa-clipboard&quot;).click(function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录 123456789. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── css | ├── _common | ├── components | ├── post 新增文件my-post-copyright.styl 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #333333; // title color font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #0593d3; // link color text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改 123456. ├── source ├── themes #主题 | ├── next #主题名 | ├── layout | ├── _macro 下的post.swig ，end post body后添加 12345678 &#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125;&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在 123456789. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── css | ├── _common | ├── components | ├── post 里的post.styl 文件尾添加 1@import &quot;my-post-copyright&quot; 我一般新建文章是在 123. ├── source ├── _posts 下的.md文件直接添加版权声明开启，栗子 123456789---title: 我是一个栗子date: 2018-11-10 10:18:13categories:- 栗子tags:- hexocopyright: true #新增,开启--- 修改标签图标 目录 123456. ├── source ├── themes #主题 | ├── next #主题名 | ├── layout | ├── _macro 把post.swig 中的 rel=”tag”&gt;# 的#替换成 ，图标可以上文章前面的网址找，替换完后要重启server 文章末尾添加文章结束提示 目录 123456. ├── source ├── themes #主题 | ├── next #主题名 | ├── layout | ├── _macro 新建passage-end-tag.swig 文件 ，内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------&lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt; this is end, thank you for reading &lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt;-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 修改同目录下post.swig文件 ，放在end post body后面，我这边放在版权声明后面 12345678910111213&#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125;&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt;&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 效果图 鼠标点击出现爱心效果 目录 1234567. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── js | ├── src 新建love.js，内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566(function(window,document,undefined)&#123;var hearts = [];window.requestAnimationFrame = (function()&#123;return window.requestAnimationFrame ||window.webkitRequestAnimationFrame ||window.mozRequestAnimationFrame ||window.oRequestAnimationFrame ||window.msRequestAnimationFrame ||function (callback)&#123;setTimeout(callback,1000/60);&#125;&#125;)();init();function init()&#123;css(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;);attachEvent();gameloop();&#125;function gameloop()&#123;for(var i=0;i&lt;hearts.length;i++)&#123;if(hearts[i].alpha &lt;=0)&#123;document.body.removeChild(hearts[i].el);hearts.splice(i,1);continue;&#125;hearts[i].y--;hearts[i].scale += 0.004;hearts[i].alpha -= 0.013;hearts[i].el.style.cssText = &quot;left:&quot;+hearts[i].x+&quot;px;top:&quot;+hearts[i].y+&quot;px;opacity:&quot;+hearts[i].alpha+&quot;;transform:scale(&quot;+hearts[i].scale+&quot;,&quot;+hearts[i].scale+&quot;) rotate(45deg);background:&quot;+hearts[i].color;&#125;requestAnimationFrame(gameloop);&#125;function attachEvent()&#123;var old = typeof window.onclick===&quot;function&quot; &amp;&amp; window.onclick;window.onclick = function(event)&#123;old &amp;&amp; old();createHeart(event);&#125;&#125;function createHeart(event)&#123;var d = document.createElement(&quot;div&quot;);d.className = &quot;heart&quot;;hearts.push(&#123;el : d,x : event.clientX - 5,y : event.clientY - 5,scale : 1,alpha : 1,color : randomColor()&#125;);document.body.appendChild(d);&#125;function css(css)&#123;var style = document.createElement(&quot;style&quot;);style.type=&quot;text/css&quot;;try&#123;style.appendChild(document.createTextNode(css));&#125;catch(ex)&#123;style.styleSheet.cssText = css;&#125;document.getElementsByTagName(&apos;head&apos;)[0].appendChild(style);&#125;function randomColor()&#123;return &quot;rgb(&quot;+(~~(Math.random()*255))+&quot;,&quot;+(~~(Math.random()*255))+&quot;,&quot;+(~~(Math.random()*255))+&quot;)&quot;;&#125;&#125;)(window,document); 目录 12345. ├── source ├── themes #主题 | ├── next #主题名 | ├── layout _layout.swig文件末尾添加一下 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 为blog设置一只小可爱 git bash键入 npm install -save hexo-helper-live2d 去github地址 https://github.com/xiazeyu/live2d-widget-models 选择自己想要的model，比如我选了个黑猫model live2d-widget-model-hijiki，需要 npm install --save live2d-widget-model-hijiki 安装模块 随后在站点配置文件里加入 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-hijiki display: position: right width: 100 height: 100 mobile: show: true 设置网站图标 在网址 https://www.easyicon.net/找一张（32*32）的ico图标 把图标放在 123456. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── images 修改主题配置文件 12345favicon: small: /images/favicon-16x16-next.png medium: /images/你下载的图标.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 设置背景图片目录 1234567. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── css | ├── _custom 下 custom.styl 文件 新增这些，这个配置可以保证图片全屏显示，有的文章的配置会有显示不全屏的情况 12345678910111213@media screen and (min-width:1200px) &#123; body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; &#125; #footer a &#123; color:#eee; &#125;&#125; 设置可交互背景 进入 theme/next 执行命令 git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 下载动态js文件 配置主题配置文件canvas_nest 为true 添加github图标链接 链接图标选择地址 http://tholman.com/github-corners/ 把代码复制到目录 12345. ├── source ├── themes #主题 | ├── next #主题名 | ├── layout 下的_layout.swig 文件中的 &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 下面，并把href指向修改为你的github地址 设置圆形动态头像 设置头像前面已经说过了 接下在目录 123456789. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── css | ├── _common | ├── components | ├── sidebar 下的sidebar-author.styl 新增 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 设置代码块样式 目录 1234567. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── css | ├── _custom 下文件custom.styl 新增 123456789101112131415//代码块` `样式code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 测试，我是一行快乐的代码块 网页底部添加blog运行时长 目录 123456. ├── source ├── themes #主题 | ├── next #主题名 | ├── layout | ├── _partials 下footer.swig文件头部添加 1234567891011121314151617181920212223242526&lt;div id=&quot;days&quot;&gt;&lt;/div&gt;&lt;script&gt;function show_date_time()&#123;window.setTimeout(&quot;show_date_time()&quot;, 1000);BirthDay=new Date(&quot;05/27/2017 15:13:14&quot;);today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000e_daysold=timeold/msPerDaydaysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById(&apos;days&apos;).innerHTML=&quot;已运行&quot;+daysold+&quot;天&quot;+hrsold+&quot;小时&quot;+minsold+&quot;分&quot;+seconds+&quot;秒&quot;;&#125;function setzero(i)&#123;if (i&lt;10)&#123;i=&quot;0&quot; + i&#125;;return i;&#125;show_date_time();&lt;/script&gt; 接下来我是在原本的访客记录位置下添加 &lt;div id=&quot;days&quot;&gt;&lt;/div&gt; 添加文章图片点击放大功能 目录 1234567. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── js | ├── src 中文件post-details.js最后面添加 123456789101112131415161718192021222324252627//----点击 图片放大js----------------function createImgEventFullScreen() &#123; var imgs = $(&quot;.post-body&quot;).find(&quot;img&quot;); console.log(imgs); for(var i = 0;i &lt; imgs.length;i++) &#123; // $(imgs[i]).click(createCover(imgs[i])); imgs[i].onclick= function(e) &#123; var src = e.srcElement.currentSrc; createCover(src) &#125; &#125; function createCover (src) &#123; console.log(src); var cover = $(&quot;&lt;div id=&apos;fullScreenCover&apos; class=&apos;zhou-cover-img-container&apos;&gt;&lt;img class=&apos;zhou-cover-img&apos; src=&apos;&quot;+src+&quot;&apos;/&gt;&lt;/div&gt;&quot;); $(&quot;#fullScreenCover&quot;).remove(); $(&quot;body&quot;).append(cover); $(&quot;body&quot;).addClass(&quot;zhou-no-scroll&quot;); $(&quot;#fullScreenCover&quot;).click(function()&#123; $(&quot;#fullScreenCover&quot;).remove(); $(&quot;body&quot;).removeClass(&quot;zhou-no-scroll&quot;); &#125;) &#125;&#125;setTimeout(function()&#123; createImgEventFullScreen();&#125;,1000) 目录 1234567. ├── source ├── themes #主题 | ├── next #主题名 | ├── source | ├── css | ├── _custom 中文件custom.styl最后添加 1234567891011121314151617181920.zhou-cover-img-container&#123; position: fixed; top: 10%; left: 10%; width: 80%; height: 80%; z-index: 10002; text-align: center; background-color: #000;&#125;.zhou-cover-img&#123; left: 0; height: 100%; width: 100%; position: absolute; top: 0; bottom: 0;&#125; 目录 12345. ├── source ├── node_modules | ├── hexo-blog-encrypt | ├── lib 中修改blog-encrypt.js ，在 $(&#39;#encrypt-blog&#39;).html(content); 后面加上 createImgEventFullScreen(); ….blog美化先到这里吧，感觉有点被榨干了，虽然说还有些高阶优化，后面再补充吧，以上。效果图 更多效果请移步，blog：https://qq1028951741.github.io/ 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>hexo-blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速利用hexo搭建blog？]]></title>
    <url>%2F2018%2F11%2F10%2Fhexo1%2F</url>
    <content type="text"><![CDATA[如何快速利用hexo搭建blog？安装需要的工具 安装nodejs，最新版本自带npm，然后cmd，查看node -v，若有相应版本，则安装成功。 npm默认的源的下载速度可能很慢，建议使用淘宝镜像替换。 npm config set registry &quot;https://registry.npm.taobao.org&quot; 安装git 安装hexo 新建hexo文件夹 空白处右键git bash here 键入npm install hexo -g #-g表示全局安装, npm默认为当前项目安装 查看hexo version，有相应信息，则安装成功 让hexo跑起来~ 在hexo文件夹右键git bash here 执行hexo init，执行完生成如下目录结构 1234567891011.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 执行npm install安装hexo所需模块 执行hexo generate生成静态文件 执行hexo s本地部署 访问http://localhost:4000/ Congratulations~~~ 人生两苦：想要却不得，拥有却失去。 –褚禄山 珍惜当下,与君共勉~]]></content>
      <categories>
        <category>hexo-blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是一个栗子]]></title>
    <url>%2F2018%2F11%2F10%2F%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%97%E5%AD%90%2F</url>
    <content type="text"><![CDATA[网站:This is an example link.]]></content>
      <categories>
        <category>栗子</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>栗子</tag>
        <tag>我也是一个栗子</tag>
      </tags>
  </entry>
</search>
